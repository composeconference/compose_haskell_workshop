<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<title>Melbourne Haskell Workshop 2013</title>
		<link href="resources/css/styles.css" rel="stylesheet" type="text/css">
		<link href="resources/css/solarized-light.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<div id="content">

<p>----</p>
<p></p>
<h1 id="adts-algebraic-data-types">ADTs (Algebraic Data Types)</h1>
<div class="center">
<a href="http://www.haskell.org/haskellwiki/Algebraic_data_type">Haskell Wiki Link</a>
</div>

<p>Algebraic Data Types are THE bread and butter of Haskell programs.</p>
<ul>
<li>Functions evaluate data by pattern-matching against ADTs</li>
<li>Domains are modeled using ADTs</li>
<li>Laziness is linked to ADTs</li>
<li>Types can be derived from ADT definitions</li>
</ul>
<div class="collapse">

<p>But how does that help me?</p>
<p>An example of an ADT in Haskell:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyBool = MyTrue | MyFalse | MyNotSure

should_I_eat_something_bigger_than_my_own_head :: MyBool
should_I_eat_something_bigger_than_my_own_head = MyFalse</code></pre>
<pre class="real"><code>With this functionality, you are able to introduce your own &quot;Enum&quot;
values.

The MyBool example is somewhat equivalent to the following C++ code:

enum MyBool { MyTrue, MyFalse, MyNotSure };

With the added bonus of not having out-of-bounds casting ruin your day.

If your problem space can be moddeled using various discrete values,
then this form of ADT will allow you to create a program that mirrors
your problem!</code></pre>
<p>You can add parameters to the data constructors:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyNullString = Nada | MyString String

stringy :: MyNullString
stringy = MyString &quot;Whatever, It&#39;s just a string&quot;

blanky :: MyNullString
blanky = Nada</code></pre>
<p>Constructors can take multiple parameters:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data SomeJunk = Rubbish String | TrashPile String Int Bool

discards :: SomeJunk
discards = TrashPile &quot;Junk Yard&quot; 42 True</code></pre>
<p>Furthermore, ADTs can be recursive:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyNumberList = Nada | SomeNumbers Int MyNumberList

numbers :: MyNumberList
numbers =  SomeNumbers 1 (SomeNumbers 2 Nada)</code></pre>
<p>Finally, ADTs can be parametrised by other types:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyContainer x = Jar x

contained :: MyContainer Int
contained = Jar 1

pun :: MyContainer (MyContainer String)
pun = Jar (Jar &quot;Binks&quot;)</code></pre>
<p>In general, the syntax of an ADT looks similar to the following:</p>
<pre class="bnf"><code>ADT          := data &lt;TypeName&gt; &lt;Variables&gt; = &lt;Constructors&gt;
TypeName     := [A-Z] + [a-z&#39;_]*
Parameters   := &lt;ConcreteType&gt; + (&quot; &quot; + &lt;ConcreteType&gt;)*
Constructors := &lt;Constructor&gt; + (&quot; | &quot; + &lt;Constructor&gt;)*
Constructor  := &lt;TypeName&gt; + &lt;Parameters&gt;
Variables    := &lt;Variable&gt; + (&quot; &quot; + &lt;Variable&gt;)*
Variable     := [a-z] + [a-z&#39;_]*</code></pre>
<p>ConcreteType can't be defined syntactically, but it means that your type is &quot;Fully Applied&quot; (in Haskell terms, has a kind of <code>*</code>). An example of some concrete types are:</p>
<ul>
<li><code>String</code></li>
<li><code>Int</code></li>
<li><code>Maybe String</code></li>
<li><code>[Int]</code></li>
</ul>
<p>Examples of some non-concrete types are:</p>
<p>With all of this power at your disposal, it's time to define a list ADT yourself.</p>
</div>

<pre class="instruction"><code>Ex. 3a.1 - Define your own list ADT.</code></pre>
<p>Things to consider:</p>
<ul>
<li>Should this ADT be parametrised?</li>
<li>Should this ADT be recursive?</li>
<li>Should this ADT have multiple constructors?</li>
<li>Should the constructors be parametrised?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyList a = Empty | Items a (MyList a)</code></pre>
<pre class="instruction"><code>An open-ended question:

What would the ADT for a LISP-like language look like?</code></pre>
<div class="note">
<p>If you wish to learn about why ADTs are &quot;Algebraic&quot;, then have a look at:</p>
<ul>
<li><a href="http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/">The Algebra of Algebraic Data Types, Part 1</a></li>
<li><a href="http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/">The Algebra of Algebraic Data Types, Part 2</a></li>
<li><a href="http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/">The Algebra of Algebraic Data Types, Part 3</a>
</div>

</li>
</ul>
			<hr>
			<p class="center footer"> Produced with <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a> </p>
		</div>
		<script type="text/javascript" src="resources/javascript/rainbow-custom.min.js"></script>
		<script type="text/javascript" src="resources/javascript/answers.js"></script>
		<script type="text/javascript" src="resources/javascript/collapse.js"></script>
	</body>
</html>
