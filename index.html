<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<title>Compose :: Melbourne 2016 Haskell Workshop</title>
		<link href="resources/css/styles.css"          rel="stylesheet" type="text/css">
		<link href="resources/css/toc.css"             rel="stylesheet" type="text/css">
		<link href="resources/css/fonts.css"           rel="stylesheet" type="text/css">
		<link href="resources/css/solarized-light.css" rel="stylesheet" type="text/css">
	</head>
	<body class="">
		<div id="content">



<div class='chapter'>
<div class='content'>

<h1 id="compose-melbourne-2016-haskell-workshop">Compose :: Melbourne 2016 Haskell Workshop</h1>
<div class="important">
<pre class="note notitle"><code>Press &quot;o&quot; to toggle only showing the most important content
Press &quot;t&quot; to toggle showing the table of contents</code></pre>
</div>
<div class="center important">
<p>A single-day workshop intended to introduce Haskell to newcomers to functional-programming.</p>
</div>
<div class="center nopad">
<img src="resources/images/ComposeConference-Melbourne-02.png" alt="Workshop" />
</div>
<p>Outcomes include...</p>
<ul>
<li>Creating, editing, running and interacting with Haskell programs</li>
<li>Building the confidence to solve problems in the wild with Haskell</li>
<li>Developing an understanding of the Haskell ecosystem</li>
<li>Interacting with others in a collaborative environment</li>
</ul>
<div class="important note">
<p>If you are attending the workshop, make sure that you RSVP via <a href="https://www.eventbrite.com.au/e/haskell-workshop-compose-conference-melbourne-2016-tickets-26654564520">Eventbrite</a>. Please also attempt to have the required items from the <a href="#resources">'Resources'</a> section available for your use during the workshop.</p>
<p>If you would like to volunteer to help assist at the workshop, please send an email to the <script type="text/javascript">
<!--
h='&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#46;&#x63;&#x6f;&#x6d;';a='&#64;';n='&#x63;&#x6f;&#x6d;&#112;&#x6f;&#x73;&#x65;&#x6d;&#x65;&#108;&#x2d;&#x61;&#100;&#x6d;&#x69;&#110;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+'Compose :: Melbourne Committee'+'<\/'+'a'+'>');
// -->
</script><noscript>&#x43;&#x6f;&#x6d;&#112;&#x6f;&#x73;&#x65;&#32;&#58;&#58;&#32;&#x4d;&#x65;&#108;&#98;&#x6f;&#x75;&#114;&#110;&#x65;&#32;&#x43;&#x6f;&#x6d;&#x6d;&#x69;&#116;&#116;&#x65;&#x65;&#32;&#40;&#x63;&#x6f;&#x6d;&#112;&#x6f;&#x73;&#x65;&#x6d;&#x65;&#108;&#x2d;&#x61;&#100;&#x6d;&#x69;&#110;&#32;&#x61;&#116;&#32;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#x6f;&#x6d;&#x29;</noscript>.</p>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="table-of-contents">Table of Contents</h1>
<div id="toc" class="important">
<!-- Note: This is a special file that determines the order of the chapters                  -->
<!--       The lefthand column refers to the filename of the chapter in 'resources/markdown' -->
<!--       This column is removed before the markdown is processed for the table of contents -->
<!--       ';' is a comment                                                                  -->
<table>
<tbody>
<tr class="odd">
<td align="left"><a href="#required-resources">Resources</a></td>
<td align="left">Resources Available and Required</td>
<td align="left">1m</td>
</tr>
<tr class="even">
<td align="left"><a href="#welcome">Welcome</a></td>
<td align="left">Motivation, Overview, and Approach</td>
<td align="left">15m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#setup">Setup</a></td>
<td align="left">Setting up your Haskell environment</td>
<td align="left">15m</td>
</tr>
<tr class="even">
<td align="left"><a href="#ecosystem">Ecosystem</a></td>
<td align="left">Resources and Community</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#introduction">Introduction</a></td>
<td align="left">Introductory Exercises</td>
<td align="left">30m</td>
</tr>
<tr class="even">
<td align="left"><a href="#types">Types</a></td>
<td align="left">The Haskell Type System</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#adts-algebraic-data-types">ADTs</a></td>
<td align="left">Modelling with data in Haskell</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#typeclasses">Type-Classes</a></td>
<td align="left">Polymorphism, FP style</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#monads">Monads</a></td>
<td align="left">IO Monad, Do-Notation</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#lets-make-a-guessing-game">Guessing-Game</a></td>
<td align="left">Let's Make a Guessing Game</td>
<td align="left">1h</td>
</tr>
</tbody>
</table>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="required-resources">Required Resources</h1>
<p>Before you begin you will require the following...</p>
<h2 id="a-text-editor" class="important">A Text-Editor</h2>
<p>We are assuming previous programming experience, however, if you would like a recommendation, have a look at <a href="https://atom.io/">Atom</a>, <a href="https://code.visualstudio.com/">Visual Studio Code</a>, <a href="http://www.gnu.org/software/emacs/">Emacs</a> or <a href="http://www.vim.org/">Vim</a>. Just make sure that you are fluent enough to embark on exercises as they appear in the workshop.</p>
<h2 id="stack" class="important"><a href="https://docs.haskellstack.org/en/stable/README/">Stack</a></h2>
<p>In order to run the programs written during this workshop you will need a Haskell installation. The easiest way to get up and running is to install Stack.</p>
<h2 id="a-copy-of-the-workshop-github-project"><a href="https://github.com/composeconference/compose_haskell_workshop">A Copy of the Workshop Github Project</a></h2>
<p>The exercises in the project are available in runnable form in the workshop source.</p>
<p>You can grab the source from GitHub:</p>
<pre class="shell"><code>git clone https://github.com/composeconference/compose_haskell_workshop.git</code></pre>
<h1 id="other-useful-resources" class="collapse">Other Useful Resources</h1>
<p>These resources are available to help you with any issues you face when learning Haskell:</p>
<h2 id="haskell-on-freenode">#haskell on <a href="http://freenode.net/">Freenode</a></h2>
<p>An IRC channel dedicated to discussion of Haskell. This is often the easiest place to fire off a one-off question that is simple enough not to warrant a permanent listing on the internet.</p>
<h2 id="hackage"><a href="http://hackage.haskell.org/packages/hackage.html">Hackage</a></h2>
<p>Hackage is the primary repository for Haskell packages. It is public, searchable, versioned, and uses Cabal package metadata for classification. Furthermore, this can be used to easily browse package contents, documentation and source-code.</p>
<p>For example, browse the <a href="http://hackage.haskell.org/package/shake">Shake</a> package and look at some of the <a href="http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake-Command.html">Modules</a>.</p>
<h2 id="hoogle"><a href="http://www.haskell.org/hoogle/">Hoogle</a></h2>
<p>Hoogle is a Haskell module and function search-engine. Hoogle allows you to take advantage of the granular type-system used by Haskell to search not just for function-names, but for function type-signatures.</p>
<p>For example, have a look for the function with signature <a href="http://www.haskell.org/hoogle/?hoogle=Text+-%3E+ByteString">Text -&gt; ByteString</a>.</p>
<h2 id="mfug"><a href="http://www.meetup.com/Melbourne-Functional-User-Group-MFUG/">MFUG</a></h2>
<p>MFUG is the Melbourne Functional Programmer's User Group. This group discusses many topics, including Haskell.</p>
<h2 id="rhaskell"><a href="http://www.reddit.com/r/haskell">/r/haskell</a></h2>
<p>For Reddit users, /r/haskell is a very useful resource with a great deal of information regarding recent developments in the Haskell ecosystem and community. This is a good place to ask some more advanced questions or start a flame-war.</p>
<h2 id="haskell-news"><a href="http://haskellnews.org/">Haskell News</a></h2>
<p>Haskell News is a firehose-style haskell news aggregator taking information from sources as varied as academic-journals, and GitHub accounts.</p>
<h2 id="hlint"><a href="http://hackage.haskell.org/package/hlint">HLint</a></h2>
<p>HLint is a <a href="http://en.wikipedia.org/wiki/Lint_(software)">linting tool</a> for Haskell source - It can often provide some useful hints about refactoring avenues for your code.</p>
<h2 id="learn-you-a-haskell-for-great-good"><a href="http://learnyouahaskell.com/">Learn You a Haskell (For Great Good)</a></h2>
<p>Learn You a Haskell (For Great Good) is a wonderful introductory text on Haskell.</p>
<h2 id="real-world-haskell"><a href="http://book.realworldhaskell.org/">Real World Haskell</a></h2>
<p>Real World Haskell aims to focus on solving real problems with Haskell. Several chapters of the book are somewhat dated in terms of the libraries used, but it still serves as a useful example of getting real work done with Haskell.</p>
<h2 id="haskell-programming-from-first-principles"><a href="http://haskellbook.com/">Haskell Programming from First Principles</a></h2>
<p>The latest and greatest comprehensive text for learning Haskell.</p>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="welcome">Welcome</h1>
<div class="important">
<p>Welcome to the Compose :: Melbourne 2016 Haskell Workshop.</p>
<p>This intent of this workshop is to provide a working introduction to Haskell for programmers in Melbourne who have not yet used the language in anger.</p>
<p>The workshop is split into chapters. The chapters will start with a few trivial introductory exercises to get your fingers warmed up, then the meat - exercises that should be able to be solved using the material introduced up to that point (with help and hints available if needed).</p>
<p>Each chapter will conclude with an open-question. This question should provide inspiration for further consideration of how harder problems could be solved using Haskell, and for more advanced attendees, can be attacked instead of twiddling your thumbs after finishing the main exercise.</p>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="setup">Setup</h1>
<div class="important">
<p>Ensure that you have the following programs installed and functioning correctly:</p>
<h2 id="stack"><a href="https://docs.haskellstack.org/en/stable/README/">Stack</a></h2>
<p>Check that you have stack installed:</p>
<pre class="shell"><code>stack --version</code></pre>
<p>This should output something similar to:</p>
<pre><code>Version 1.1.2 x86_64 hpack-0.14.0</code></pre>
<p>Otherwise, install it!</p>
<pre class="shell"><code>curl -sSL https://get.haskellstack.org/ | sh
stack setup
stack ghci
&gt; 1 + 1</code></pre>
<p>This should output:</p>
<pre><code>2</code></pre>
</div>
<pre class="real"><code>You can use GHCi to perform calculations other than just &quot;1 + 1&quot;.

Here is an example session:

[Prelude] &gt; 1 + 2 + 3
6
[Prelude] &gt; 100 / 2
50.0
[Prelude] &gt; 6 ^ 7
279936
[Prelude] &gt; ^D
Leaving GHCi.</code></pre>
<pre class="instruction"><code>Using GHCi...

Calculate the price of 42-bakers-dozens of eggs at $3 per-egg.</code></pre>
<pre class="answer"><code>[Prelude] 42 * 13 * 3
1638</code></pre>
<pre class="note"><code>If ghci is on your PATH, then you can invoke it directly,
however, if you have just installed stack, then you will
need to invoke ghci indirectly by calling

&gt; stack exec -- ghci [ARGS]
</code></pre>
<h2 id="loading-files-in-ghci" class="important">Loading files in GHCi</h2>
<p>There are many ways to load and execute Haskell code. For the purposes of this workshop, if you do not already have a workflow you are comfortable with, then we suggest the following steps:</p>
<ul>
<li>Write and edit your programs in files ending in the extension &quot;.hs&quot;</li>
<li>When you are ready to test your program, load it into GHCi</li>
<li>After making modifications to your program, reload the program in GHCi</li>
</ul>
<p>Say you had written the following program <code>test.hs</code>:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>main = print &quot;hello world&quot;
</code></pre>
<p>Load the file in GHCi to see it in action:</p>
<pre class="shell"><code>&gt; stack exec -- ghci test.hs
GHCi, version 7.6.2: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, modules loaded: Main.
[*Main] &gt; main
&quot;hello world&quot;</code></pre>
<p>... Unfortunately there is a bug in the program, so in your editor you make the change required to print &quot;hello, world&quot; with the mandated comma:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>main = print &quot;hello, world&quot;
</code></pre>
<p>Now, back in GHCi, you can reload the program without exiting the REPL:</p>
<pre class="shell"><code>[*Main] &gt; :reload
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, modules loaded: Main.
[*Main] &gt; main
&quot;hello, world&quot;</code></pre>
<p>Much better!</p>
<pre class="real"><code>You can inspect a value (of function) in ghci with the `:info` command
in order to find out a little about its type and definition:

ghci&gt; :info main
main :: IO ()   -- Defined at test.hs:1:1

If you just wish to see the type of an expresison, you can use
the `:type` command:

ghci&gt; :type main
main :: IO ()</code></pre>
<pre class="instruction"><code>

* Define a new numeric function in a source file
* Load it in GHCi
* Test your function in GHCi
* Make a modification
* Reload your chages without exiting GHCi
* Test your changes</code></pre>
<h2 id="ghc" class="important">GHC</h2>
<p>Create the following source file (program.hs):</p>
<pre data-language="haskell"><code>main = print &quot;hello world&quot;</code></pre>
<p>Compile the program as follows:</p>
<pre class="shell"><code>ghc --make program.hs</code></pre>
<p>Run the program with the following command:</p>
<pre class="shell"><code>./program</code></pre>
<p>The output should look as follows:</p>
<pre class="text"><code>&quot;hello world&quot;</code></pre>
<pre class="real"><code>Compiled programs are almost always significantly faster than instructions
run inside GHCi. Even greater speed-ups are possible by using the &quot;-O&quot;
optimisation settings for GHC.</code></pre>
<pre class="instruction"><code>Using GHC...

Compile and run hello-world.</code></pre>
<pre class="answer"><code>&gt; echo &#39;main = print &quot;hello friends&quot;&#39; &gt; main.hs
&gt; ghc --make main.hs
[1 of 1] Compiling Main             ( main.hs, main.o )
Linking main ...
&gt; ./main
&quot;hello friends&quot;</code></pre>
<h2 id="cabal" class="important">Cabal</h2>
<p>You should have access to a Cabal installation if you have installed the Haskell Platform.</p>
<p>Check that you have cabal by running:</p>
<pre class="shell"><code>cabal --version</code></pre>
<p>This should output something similar to:</p>
<pre class="text"><code>cabal-install version &lt;VERSION&gt;
using version &lt;VERSION&gt; of the Cabal library</code></pre>
<pre class="instruction"><code>Install the QuickCheck package using cabal.</code></pre>
<pre class="note"><code>On OS X, The Haskell-Platform will install binaries in
$HOME/Library/Haskell/bin

Make sure that this is on your path.</code></pre>
<pre class="answer"><code>&gt; cabal update # not required if done recently
Downloading the latest package list from hackage.haskell.org
&gt; cabal install quickcheck
...</code></pre>
<pre class="open"><code>An open-ended question:

Given that GHC is largely written in Haskell, how was GHC first compiled?</code></pre>
<pre class="open"><code>An open-ended question:

What are some of the current issues with the Haskell ecosystem?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="ecosystem">Ecosystem</h1>
<p>The Haskell ecosystem is large and interesting, it is held together more by convention than by dictation, with the current convention being that open source packages are made available through <code>cabal</code> on Hackage.</p>
<h2 id="cabal">Cabal</h2>
<p>Cabal is a library package, but &quot;cabal&quot; is often used to refer to the cabal executable provided by the &quot;cabal-install&quot; package. These packages are both provided by the Haskell Platform.</p>
<p>The premiere online Cabal package repository is <a href="http://hackage.haskell.org/">Hackage.</a></p>
<p>Cabal provides mechanisms for download and installing packages from Hackage onto your system. It also provides a consistent way to structure, export, test, and package your own programs.</p>
<pre class="instruction"><code> 

Install the hlint package from hackage.

Use the `hlint` command-line program to to check for stylistic issues in one
of your previous solutions.</code></pre>
<pre class="answer"><code>Information about the hlint package can be found at

* hackage.haskell.org/package/hlint
* http://www.haskell.org/hoogle/?hoogle=hlint

etc.

The command used to install the hlint package is

&gt; cabal install hlint

Although you may have to run

&gt; cabal update

to ensure that your list of packages is up to date.

Once you have the hlint tool installed you can run it like so:

&gt; hlint dragon.hs

    dragon.hs:35:17: Warning: Redundant $
    Found:
      flip zip (map toLower text) $ dragon_points
    Why not:
      flip zip (map toLower text) dragon_points</code></pre>
<pre class="open"><code>An open-ended question:

How would you go about publishing your own package to Hackage?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="introduction">Introduction</h1>
<div class="important">
<p>The following exercises are intended to be used to warm up your fingers, rather than your brain. These should be run through quickly to get you used to using your development environment.</p>
</div>
<h2 id="primitives">Primitives</h2>
<p>Haskell comes pre-packaged with many primitives available in the <code>Prelude</code> module that is included by default, but you should at least make yourself familiar with the following types, and literal syntax:</p>
<table>
<colgroup>
<col width="16%" />
<col width="18%" />
<col width="18%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">What?</th>
<th align="left">Type</th>
<th align="left">Literal Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Machine Ints</td>
<td align="left">Int</td>
<td align="left">42</td>
</tr>
<tr class="even">
<td align="left">Strings</td>
<td align="left">String, [Char]</td>
<td align="left">&quot;Hello World&quot;</td>
</tr>
<tr class="odd">
<td align="left">Booleans</td>
<td align="left">Bool</td>
<td align="left">True , False</td>
</tr>
</tbody>
</table>
<pre class="real"><code>You can type any literal directly into GHCi in order to have it echoed right
back at you. This may be useful for sanity checking that you have the syntax
right!

ghci&gt; 42
42</code></pre>
<h2 id="variables">Variables</h2>
<p>In Haskell you can define a variable with the <code>=</code> sign.</p>
<p>Variables can be defined at the top-level (no-indentation):</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myVariable = 2
</code></pre>
<p>Variable names should start with a lowercase letter and contain no spaces, or special characters, besides underscores, numbers, and <code>'</code>.</p>
<pre class="real"><code>If you wish to define a variable inside GHCi, you have to prefix
the definition with &quot;let&quot;... For example:

[Prelude] &gt; let myName = &quot;Simon&quot;</code></pre>
<p>Some examples of variable names are:</p>
<ul>
<li><code>a</code></li>
<li><code>my_name</code></li>
<li><code>data43'</code></li>
</ul>
<pre class="instruction"><code>Define your own variable.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>x = &quot;hello&quot;
</code></pre>
<pre class="instruction"><code>What is an example of an invalid variable name?</code></pre>
<pre class="answer nocheck" data-language="haskell"><code>invalid-variable = 123</code></pre>
<p>String literals look familiar:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myString = &quot;hello world&quot;
</code></pre>
<pre class="instruction"><code>Define a variable containing a string.</code></pre>
<h2 id="tuples">Tuples</h2>
<p>Tuples look like this:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myTuplePair = (1,&quot;hello&quot;)

myTupleTrio = (1,&quot;hello&quot;,3)
</code></pre>
<p>They can be used to group multiple, differently-typed (heterogeneous) values.</p>
<pre class="instruction"><code>Define a variable containing a tuple.</code></pre>
<h2 id="functions">Functions</h2>
<p>Functions are a core part of Haskell. Function definitions look like this:</p>
<pre class="nocheck" data-language="haskell"><code>myFunction x y ... = ...</code></pre>
<p>For example:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myAdd x y = x + y
</code></pre>
<p><code>myAdd</code> takes two numbers and returns the result of the addition of those two numbers.</p>
<pre class="instruction"><code>Define a function `myMultiply` that multiplies 3 numbers.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply x y z = x * y * z
</code></pre>
<h2 id="lists">Lists</h2>
<p>List are a commonly used data-structure in Haskell. Everything in a list has the same type (they are homogeneous).</p>
<p>Lists are built using the infix data-constructor <code>(:)</code> (pronounced &quot;cons&quot;). They also have a compact notation using <code>[...]</code>.</p>
<p>List literals look like:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>list1 = [1,2,3]
list2 = 1 : 2 : []
list3 = &quot;hello&quot; : &quot;world&quot; : []
</code></pre>
<p>More information about why lists can be used the way that they are is contained in the <a href="#adts-algebraic-data-types">ADTs</a> chapter.</p>
<pre class="instruction"><code>Define a variable containing a list.</code></pre>
<p>You can deconstruct a list by pattern matching the head and tail like so:</p>
<pre class="nocheck" data-language="haskell"><code>f (x:xs) = ...</code></pre>
<pre class="instruction"><code>Define a function to get the first element of a list.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myHead (x:xs) = x -- This is a partial function, Beware!
</code></pre>
<p>In <code>Prelude</code> this function is called <code>head</code>.</p>
<pre class="note"><code>&quot;head&quot; is a partial function - It will raise an exception if
called with an empty list.

In Haskell we generally wish to avoid defining partial functions.</code></pre>
<pre class="instruction"><code>Define a variable containing the first element of your list.</code></pre>
<pre class="answer nocheck" data-language="haskell"><code>myFirstElement = myHead myList</code></pre>
<h3 id="define-length">Define Length</h3>
<pre class="instruction"><code>Define a function that takes a list and returns the length.</code></pre>
<p>Your solution should have the form of:</p>
<pre class="nocheck" data-language="haskell"><code>myLength []     = ...
myLength (x:xs) = ...</code></pre>
<p>Things to consider:</p>
<ul>
<li>What is the length of an empty list? (the base case)</li>
<li>What is the length of xs?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myLength []     = 0
myLength (x:xs) = 1 + myLength xs
</code></pre>
<h3 id="define-mymap">Define <code>myMap</code></h3>
<pre class="instruction"><code>
  
Define a function that takes a function from a to b,
and a list of &#39;a&#39;, and returns a list of &#39;b&#39;s.</code></pre>
<p>Some concrete examples of such a function may do the following:</p>
<ul>
<li>Take a function that divides integers by two, list of ints, and returns a list of doubles.</li>
<li>Take a function that turns lowercase into uppercase characters, and a String, and returns a string in CAPS.</li>
</ul>
<p>Things to consider:</p>
<ul>
<li>What is the base-case of myMap?</li>
<li>What is the inductive-case of myMap?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMap f [] = []
myMap f (x:xs) = f x : myMap f xs
</code></pre>
<h2 id="fun-list-functions">Fun List Functions</h2>
<p>For your reading pleasure, here are some definintions of common functions:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFilter f []     = []
myFilter f (x:xs) = if f x then x : myFilter f xs
                           else     myFilter f xs

myFold f z []     = z
myFold f z (x:xs) = f x (myFold f z xs)

myReverse []     = []
myReverse (x:xs) = myReverse xs ++ [x]

myElem e []     = False
myElem e (x:xs) = if e == x then True
                            else myElem e xs
</code></pre>
<pre class="open"><code>An open-ended question:

What is a good balance between safety and expressiveness in a
programming-language?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="types">Types</h1>
<pre class="note.notitle"><code>Question: How do you create a great program?
Answer:   You type it!</code></pre>
<p>In this chapter, we will go over the exercises from the introduction and add types to the examples.</p>
<hr />
<p>In Haskell, type signatures can be provided inline, or above definitions.</p>
<p>For example:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>x :: Int
x = 3
</code></pre>
<p>or</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>x = (3 :: Int)
</code></pre>
<p>It is far more common to place the type-signature above the definition, with inline types only used in situations where ambiguities need to be resolved.</p>
<div class="important">
<pre class="instruction nobefore"><code>You are defining a floating point variable:</code></pre>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFloat = 1.1
</code></pre>
<pre class="instruction"><code>Give your variable a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFloat :: Float
myFloat = 1.1
</code></pre>
</div>
<h2 id="type-synonyms">Type Synonyms</h2>
<p>In Haskell, we can give type-expressions an alias (or synonym) by using the <code>type</code> keyword. This allows you to cut down the verbosity and chance of errors in your code when you have type expressions that would otherwise be repeated frequently.</p>
<p>An example of this is the <code>String</code> type-synonym, which is defined as follows:</p>
<pre class="nocheck" data-language="haskell"><code>type String = [Char]</code></pre>
<pre class="instruction"><code> 

Give your string variable from the previous chapter a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myString :: String
myString = &quot;Hello Haskell&quot;
</code></pre>
<h2 id="tuples">Tuples</h2>
<p>Tuple type signatures look the same as the tuples themselves, with types in place of the data.</p>
<p>For example, if you had a tuple of a String and an Int, the type would look as follows:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myTuple :: (String, Int)
myTuple = (&quot;The meaning of life&quot;, 42)
</code></pre>
<pre class="instruction"><code>Give your previous tuple definition a type signature.</code></pre>
<h2 id="functions">Functions</h2>
<p>The type signatures of functions in Haskell are a little different from how they look in the more familiar C family languages, but the syntax is very elegant, and will allow a higher-level of reasoning than less consistant forms.</p>
<p>The syntax for a function type-signarure is of the form:</p>
<pre class="nocheck" data-language="haskell"><code>{functionName} :: {argument} -&gt; {result}</code></pre>
<p>The main idea is that functions in Haskell only ever take one argument. If you wish to define a function that takes more than one argument, then you should, infact, define a function that takes one argument, then returns another function.</p>
<p>Luckily the syntax for doing this in Haskell looks identical to defining a multi-argument function:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply x y z = x * y * z
</code></pre>
<p>However, the distinction becomes clear with the type-signature:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply :: Int -&gt; (Int -&gt; (Int -&gt; Int))
myMultiply x y z = x * y * z
</code></pre>
<p>It is clear, that the function only takes one argument, then returns a function (that only takes one argument, and returns a function (that only takes one argument, that returns an Int.))</p>
<p>Fortunately, Haskell's function syntax is right-associative, allowing us to drop the parentheses:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply :: Int -&gt; Int -&gt; Int -&gt; Int
myMultiply x y z = x * y * z
</code></pre>
<pre class="instruction"><code> 

Define a function `myMultiply` that multiplies 4 numbers.
Give your function a type-signature</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int
myMultiply w x y z = w * x * y * z
</code></pre>
<h2 id="lists">Lists</h2>
<p>List type-signatures look like:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>list1 :: [Int]
list2 :: [Int]
list3 :: [String]

list1 = [1,2,3]
list2 = 1 : 2 : []
list3 = &quot;hello&quot; : &quot;world&quot; : []

list1A :: ([]) Int
list1A = [1]
</code></pre>
<p>List type signatures are special in that the type-constructor is &quot;Around&quot;-fix. This is not generally possible, and lists are a special case in that regard.</p>
<p>If you find you need to, you can use the list type in prefix-form, as per variable <code>list1A</code>.</p>
<pre class="instruction"><code>Define a list variable and give it a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myList :: [Int]
myList = [1,2,3]
</code></pre>
<pre class="instruction"><code>Give your `head` deconstructor function a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myHead :: [a] -&gt; a
myHead (x:xs) = x
</code></pre>
<h3 id="length-signature">Length Signature</h3>
<pre class="instruction"><code>Give your length function a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myLength :: [a] -&gt; Int
myLength []     = 0
myLength (x:xs) = 1 + myLength xs
</code></pre>
<h3 id="map-signature">Map Signature</h3>
<pre class="instruction"><code>Give your `map` function a type-signature.</code></pre>
<p>Things to consider:</p>
<ul>
<li>What is the type of the first argument of myMap?</li>
<li>What is the second argument, etc?</li>
<li>What is the type of the result of myMap?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]
myMap f [] = []
myMap f (x:xs) = f x : myMap f xs
</code></pre>
<h2 id="fun-list-functions-types">Fun List Functions Types</h2>
<p>Here are the types for the definintions of the list functions from the previous chapter:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFilter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
myFilter f []     = []
myFilter f (x:xs) = if f x then x : myFilter f xs
                           else     myFilter f xs

myFold :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
myFold f z []     = z
myFold f z (x:xs) = f x (myFold f z xs)

myReverse :: [a] -&gt; [a]
myReverse []     = []
myReverse (x:xs) = myReverse xs ++ [x]

myElem :: Eq a =&gt; a -&gt; [a] -&gt; Bool
myElem e []     = False
myElem e (x:xs) = if e == x then True
                            else myElem e xs
</code></pre>
<pre class="instruction"><code>Try to understand the type-signatures for these functions.

Hint: Try finding a way to say them in English.</code></pre>
<pre class="open"><code>An open-ended question:

How many types could a type-checker check...
... if a type checker could check types?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="adts-algebraic-data-types">ADTs (Algebraic Data Types)</h1>
<div class="center">
<p><a href="http://www.haskell.org/haskellwiki/Algebraic_data_type">Haskell Wiki Link</a></p>
</div>
<p>Algebraic Data Types are THE bread and butter of Haskell programs.</p>
<ul>
<li>Functions evaluate data by pattern-matching against ADTs</li>
<li>Problem-domains are modeled using ADTs</li>
<li>Laziness is linked to ADTs</li>
<li>Types can be derived from ADT definitions</li>
</ul>
<div class="collapse">
<p>But how does that help me?</p>
<p>An example of an ADT in Haskell:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyBool = MyTrue | MyFalse | MyNotSure

should_I_eat_something_bigger_than_my_own_head :: MyBool
should_I_eat_something_bigger_than_my_own_head = MyFalse
</code></pre>
<pre class="real"><code>With this functionality, you are able to introduce your own &quot;Enum&quot;
values.

The MyBool example is somewhat equivalent to the following C++ code:

enum MyBool { MyTrue, MyFalse, MyNotSure };

With the added bonus of not having out-of-bounds casting ruin your day.

If your problem space can be modeled using various discrete values,
then this form of ADT will allow you to create a program that mirrors
your problem!</code></pre>
<p>You can add parameters to the data constructors:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyNullString = Nada | MyString String

stringy :: MyNullString
stringy = MyString &quot;Whatever, It&#39;s just a string&quot;

blanky :: MyNullString
blanky = Nada
</code></pre>
<p>Constructors can take multiple parameters:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data SomeJunk = Rubbish String | TrashPile String Int Bool

discards :: SomeJunk
discards = TrashPile &quot;Junk Yard&quot; 42 True
</code></pre>
<p>Furthermore, ADTs can be recursive:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyNumberList = Nada | SomeNumbers Int MyNumberList

numbers :: MyNumberList
numbers =  SomeNumbers 1 (SomeNumbers 2 Nada)
</code></pre>
<p>Finally, ADTs can be parametrised by other types:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyContainer x = Jar x

contained :: MyContainer Int
contained = Jar 1

pun :: MyContainer (MyContainer String)
pun = Jar (Jar &quot;Binks&quot;)
</code></pre>
<p>In general, the syntax of an ADT looks similar to the following:</p>
<pre class="bnf"><code>ADT          := data &lt;TypeName&gt; &lt;Variables&gt; = &lt;Constructors&gt;
TypeName     := [A-Z] + [a-z&#39;_]*
Parameters   := &lt;ConcreteType&gt; + (&quot; &quot; + &lt;ConcreteType&gt;)*
Constructors := &lt;Constructor&gt; + (&quot; | &quot; + &lt;Constructor&gt;)*
Constructor  := &lt;TypeName&gt; + &lt;Parameters&gt;
Variables    := &lt;Variable&gt; + (&quot; &quot; + &lt;Variable&gt;)*
Variable     := [a-z] + [a-z&#39;_]*</code></pre>
<p>ConcreteType can't be defined syntactically, but it means that your type is &quot;Fully Applied&quot; (in Haskell terms, of <strong>kind</strong> <code>*</code>). An example of some concrete types are:</p>
<ul>
<li><code>String</code></li>
<li><code>Int</code></li>
<li><code>Maybe String</code></li>
<li><code>[Int]</code></li>
</ul>
<p>Examples of some non-concrete types are:</p>
<ul>
<li><code>Maybe</code></li>
<li><code>IO</code></li>
<li><code>(-&gt;)</code></li>
</ul>
<h2 id="deriving">Deriving</h2>
<p>One final thing to note is that in order to be able to print values of your data types at the GHCi REPL, you will need your data to be a member of the <code>Show</code> type-class.</p>
<p><em>Type-classes are covered in depth in the <a href="#typeclasses">type-classes</a> chapter.</em></p>
<p>This is achieved by appending the following text after your data definition:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyData = SuperGreat deriving (Show)
</code></pre>
<p>Similar classes are needed for ordering and equality. If you get stuck on a missing class, just add the following deriving triple for now:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyData = SuperGreat deriving (Eq, Ord, Show)
</code></pre>
<h2 id="exercises">Exercises</h2>
<p>With all of this power at your disposal, it's time to define a list ADT yourself.</p>
</div>
<pre class="instruction"><code>Define your own generic list ADT.</code></pre>
<p>Things to consider:</p>
<ul>
<li>Should this ADT be parametrised?</li>
<li>Should this ADT be recursive?</li>
<li>Should this ADT have multiple constructors?</li>
<li>Should the constructors be parametrised?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyList a = Empty | Items a (MyList a)
</code></pre>
<pre class="open"><code>An open-ended question:

What would the ADT for a Lisp-like language look like?</code></pre>
<div class="note">
<p>If you wish to learn about why ADTs are &quot;Algebraic&quot;, then have a look at:</p>
<ul>
<li><a href="http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/">The Algebra of Algebraic Data Types, Part 1</a></li>
<li><a href="http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/">The Algebra of Algebraic Data Types, Part 2</a></li>
<li><a href="http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/">The Algebra of Algebraic Data Types, Part 3</a></li>
</ul>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<h1 id="typeclasses">Type Classes</h1>
<p>A big part of writing clean reusable code is controlled polymorphism. We are like a carny at the roller-coaster, anybody can ride the roller coaster, but you must be at least this tall.</p>
<p>In the object oriented world we use the inheritance heirachy, we know that if something is a subclass, it has at least all of the features of its parent. Of course this is all intertwined with the sharing of data and state, and that's bad.</p>
<p>In the functional world we get type classes, which is just controlled polymorphism without the baggage. They basically say, that I don't need to know exactly what type you'll call me with but you need to provide a bunch of functions for me to use.</p>
<p>A function tells you what type classes it needs with a &quot;context&quot;, The context is the bit to the left of the double arrow &quot;=&gt;&quot;</p>
<pre class="nocheck" data-language="haskell"><code>(+) :: Num a =&gt; a -&gt; a -&gt; a

show :: Show a =&gt; a -&gt; String</code></pre>
<p>In the above example, we have <code>(+)</code>. It can work for any type that is a number. There are built in types for numbers and you can also define your own.</p>
<p><code>show</code> can turn any &quot;Showable&quot; type into a string. this is analogous to the <code>toString()</code> method in Java.</p>
<pre class="instruction"><code>Define a function that adds one to everything in a list.
What is the type of this function?</code></pre>
<pre class="nocheck" data-language="haskell"><code>read :: Read a =&gt; String -&gt; a

incrementAndshow :: (Num a, Show a) =&gt; a -&gt; String</code></pre>
<p>Unlike most other languages, with some kind of type driven function dispatch (e.g. methods, overloading). Haskell can also use the <em>return</em> type of the function to choose functionality, this can take a little getting used to, but it is powerful.</p>
<p><code>read</code> turns a string into a value of another type, although we don't know what this is yet. It depends, for example on the type of the function that you are passing the result of read into.</p>
<p><code>incrementAndShow</code> demonstrates a function that uses two type classes in its context.</p>
<pre class="instruction"><code>In ghci, convert a string to an integer using read, then covert
a string into a list of integers using read.

(Hint: use (::) to add a type to an expression)

If you just type &#39;read &quot;1&quot;&#39; in ghci you get an
error, why is this?</code></pre>
<pre class="instruction"><code>Define `incrementAndShow` which adds one to a number and
coverts it to a string.
What is they type of this function?
How did haskell infer your context?</code></pre>
<h1 id="defining-your-own-type-classes">Defining Your Own Type Classes</h1>
<p>Let's define a type class of things that can be rated, as in 1 to 5 stars or awesome to lame.</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>
data Rating = 
  SoAwesomeICried |
  PrettyCool      |
  Meh             |
  ForTheLoveOfGodMakeItEnd
  deriving Show

class Rateable r where
  rating :: r -&gt; Rating


data Beer = Coopers | Fosters | CarltonDraught
  deriving Show

instance Rateable Beer where
  rating Coopers = PrettyCool
  rating Fosters = ForTheLoveOfGodMakeItEnd
  rating CarltonDraught = Meh


data Movie = Movie String
  deriving Show

instance Rateable Movie where
  rating (Movie &quot;Bladerunner&quot;) = SoAwesomeICried
  rating (Movie &quot;Tron&quot;) = PrettyCool
  rating _ = Meh

</code></pre>
<p>When we define a type class we write out the name and the types of the functions that we want associated with this type class. We also put a type variable in our definition which refers to whatever type may instance this type class later. We can use this type variable in the definitions below. At this point we can also define default definitions for the functions.</p>
<p>We then define two new data types, <code>Beer</code> and <code>Movie</code> for which we add an &quot;instance declaration&quot; this is where we write the definitions of the type class functions specialized for beers of movies.</p>
<p>We now know how to manually add type class definitions and we could add custom <code>Show</code> instances for each of our new datatypes. However this would be a bunch of boilerplate nonsense, so we can use the handy deriving directive to automatically add a <code>Show</code> instance for us.</p>
<pre class="instruction"><code>Create your own Rateable type class and wacky Rating datatype.
Then create datatypes and instances for something you have a
strong opinion about, like cars or a political party.</code></pre>
<pre class="instruction"><code>Add a review function to your type class that returns
a short textual review.</code></pre>
<pre class="instruction"><code>Add a Rateable instance for a native type, like String.</code></pre>
<p>There are a few other cool things you can do with typeclasses that are not covered here. So if you want to know more, check out some of these other articles:</p>
<p><a href="http://www.haskell.org/tutorial/classes.html" class="uri">http://www.haskell.org/tutorial/classes.html</a></p>

</div>
</div>




<div class='chapter'>
<div class='content'>

<h1 id="monads">Monads</h1>
<h2 id="no-seriously-what-are-monads">No seriously, what are Monads?</h2>
<p>A monad is just a bunch of rules. There are many, many analogies for monads out there. Each of these analogies are useful, but can be obscuring on their own, they are just one view point. To effectively wield monads we must use many different view points together, each one revealing a little piece of the underlying structure of monads. Each view point becomes another tool in our mental toolbox.</p>
<p>So there is no one magic-bullet analogy for monads, only many complementary ones.</p>
<p>Haskell uses monads to represent side-effects. The simplist and most practical analogy is the &quot;tainted value&quot; analogy. In haskell the function that reads a file looks like this:</p>
<pre class="nocheck" data-language="haskell"><code>readFile :: FilePath -&gt; IO String</code></pre>
<p>This function can't return a normal string, because the return value has been tainted by side effects. So the IO monad is acting as a tag saying that the returned string must be treated specially.</p>
<p>But an <code>IO String</code> is not very useful to us, because we want to actually do things with it. So Haskell, in its normal paternalistic style, allows us access the <code>String</code> inside an <code>IO String</code> only in a very careful way. We use an operation call bind <code>(&gt;&gt;=)</code> to access the string.</p>
<pre class="nocheck" data-language="haskell"><code>(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b

-- Here specialized for IO and String

(&gt;&gt;=) :: IO String -&gt; (String -&gt; IO b) -&gt; IO b</code></pre>
<p>This says the only way we can &quot;look inside&quot; an <code>IO String</code> is by providing a function that takes a <code>String</code> and returns some other new value that has also been tainted by the outside world. In other words we can only look at a value &quot;inside&quot; the <code>IO</code> monad if we promise to make sure our result will also be tainted.</p>
<p>This means that if some code uses a value from the outside world, even deep inside, it cannot be hidden, it must be made explicit in the type. Tainting is a one way street, once you are tainted you can't be untainted. There is no function <code>untaint :: IO a -&gt; a</code>. One can't get an untainted value from a tainted one.</p>
<p>In fact, in haskell, the very way we construct a useful program is by ultimately creating value of type <code>IO ()</code> that we assign to special variable called <code>main</code>.</p>
<pre class="instruction"><code>Why can&#39;t one write untaint?
If you could what problems would this cause?</code></pre>
<p>One thing that can be a little strange is the type of <code>getLine</code>. In imperative languages, functions of zero arguments make some sense. They can be thought of recipies or to-do lists. In haskell a total function of type <code>() -&gt; Foo</code> is isomorphic to a constant <code>Foo</code>. Because the function only has one input value and therefore only one possible output value.</p>
<p>So let us return to <code>getLine</code>. In an imperative language it would look like <code>getLine :: () -&gt; String</code>. Our first problem is that the return value of this function is tainted by the outside world, so we need to use the <code>IO</code> monad, <code>getLine :: () -&gt; IO String</code>. Now because of the isomorphism between unit domian functions and constants we can just write <code>getLine :: IO String</code>. We call a constant of type <code>IO a</code> an &quot;IO action&quot;. Because it stands for a bunch of side effects that will be performed together.</p>
<p>This will seem strange at first, because getLine isn't really a function -- it's just a constant value! But that's okay because while the <code>IO String</code> is a constant (i.e. there is only one distinct IO action that reads a line from the console) the value <em>inside</em> the monad is not constant. It can be different each time we look inside.</p>
<pre class="nocheck" data-language="haskell"><code>&gt; getLine
hello
&quot;hello&quot;

&gt; getLine
monad
&quot;monad&quot;

&gt; getLine &gt;&gt;= (\name -&gt; putStrLn (&quot;Hello &quot; ++ name))
andy
Hello andy</code></pre>
<h2 id="one-thing-leads-to-another">One thing leads to another</h2>
<p>Often when doing IO one wants to make sure one thing happens after another, We can use <code>(&gt;&gt;=)</code> and just ignore the unwrapped value:</p>
<pre class="nocheck" data-language="haskell"><code>putStr &quot;Hello &quot; &gt;&gt;= (\_ -&gt; putStrLn &quot;World&quot;)

putStrLn &quot;One&quot; &gt;&gt;= (\_ -&gt; putStrLn &quot;Two&quot;) &gt;&gt;= (\_ -&gt; putStrLn &quot;Three&quot;)</code></pre>
<p>This pattern can be easily abstracted, it has been standardized as <code>(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</code>. This can be read as &quot;and then&quot;.</p>
<pre class="nocheck" data-language="haskell"><code>putStr &quot;Hello &quot; &gt;&gt; putStrLn &quot;World&quot;

putStrLn &quot;One&quot; &gt;&gt; putStrLn &quot;Two&quot; &gt;&gt; putStrLn &quot;Three&quot;</code></pre>
<pre class="instruction"><code>Write a program that prints something stupid, funny or rude.
Make sure to use (&gt;&gt;) somewhere.</code></pre>
<h2 id="monad-wars-iii-return-of-the-value">Monad Wars III: Return of the Value</h2>
<p>We mentioned before that there is no way to untaint a value, once it has been tainted, we can make new tainted values from it, but never untainted ones. But that begs the question, can we choose to taint a value? Indeed we can, in fact, this is a fundamental operation of a Monad. In haskell it is confusingly called <code>return :: a -&gt; IO a</code>.</p>
<p>A common pattern is to &quot;open up&quot; an <code>IO</code> with bind <code>(&gt;&gt;=)</code>, mess around with the contents then wrap it back up again with <code>return</code>. We have a function to help us with this called <code>lift</code>. Specialized for <code>IO</code> it has type <code>lift :: (a -&gt; b) -&gt; (IO a -&gt; IO b)</code>. We can use this to take a vanilla function and &quot;lift&quot; it into the IO monad. It works by unwrapping the IO monad calling our function and then wrapping the result back up again.</p>
<pre class="instruction"><code>use return to write &#39;myLiftIO :: (a -&gt; b) -&gt; IO a -&gt; IO b&#39;</code></pre>
<h2 id="do-it-do-it-good.">Do it, do it good.</h2>
<p>Sometimes when you are doing a lot of ad-hoc interleaved IO, using bind and return all over the place can become a pain in the fingers. So haskell provides special syntax for using monads, called &quot;do notation&quot;.</p>
<p>To use do notation, we start a &quot;do block&quot; with the keyword <code>do</code>. Inside a do block, statements can be written line by line and they are automatically joined using &quot;and then&quot; <code>(&gt;&gt;)</code>. This causes them to be run one after the other like in an imperative programming language. One can also easily unwrap monad values and bind them to a variable with using a left arrow &quot;&lt;-&quot; syntax.</p>
<pre class="nocheck" data-language="haskell"><code>  main = do
    putStrLn &quot;Hello World&quot;
    putStrLn &quot;Enter your name: &quot;
    name &lt;- getLine
    putStrLn (&quot;Hello: &quot; ++ name)</code></pre>
<p>The do-notation is like a DSL, under the hood it is just expanded to a chain of bind <code>(&gt;&gt;=)</code> calls. Here is what the above code would look like without do-notation:</p>
<pre class="nocheck" data-language="haskell"><code>  main  =
    putStrLn &quot;Hello World&quot; &gt;&gt;
    putStrLn &quot;Enter your name: &quot; &gt;&gt;
    getLine &gt;&gt;= (\ name -&gt;
      putStrLn (&quot;Hello: &quot; ++ name))</code></pre>
<pre class="instruction"><code>Write a program that asks for someone&#39;s first and second name,
then complements them (or makes fun of them).

For extra points ask for their age, and customize the complement
(insult) depending on how old they are.

Do it with do-notation first, then &quot;desugar&quot; it into raw bind (&gt;&gt;=) calls</code></pre>
<pre class="instruction"><code>My father once told me about an &quot;amazing AI&quot; that his
magician/programmer friend build, which could answer any yes/no
question as well as a human.

Of course it only worked if his friend was the one typing
the question! The trick being that it just counted the
number of spaces in the question. If there was an even number
it would output true, if there was an odd number, false.
You just fiddled with the wording, or snuck in an extra space,
to get the answer that you wanted...

Looks like it&#39;s time to write your super-dooper
human-level AI and see if your friends can figure
out how it works.</code></pre>
<h2 id="stay-functional-san-diego">Stay Functional, San Diego</h2>
<p>Even when we are programming with side effects, we still want our programs to follow functional principals. To stop our code ending up like C written in do-notation, there are some principals we can try to follow:</p>
<ol style="list-style-type: decimal">
<li><p>Try to do most of the work inside pure functions.</p></li>
<li><p>Don't create an IO action until the last possible moment.</p></li>
<li><p>Be declarative, think of program as declaring a pipeline or specifying an interaction, instead of being a to-do list.</p></li>
<li><p>Avoid mixing control, state and calculation. Instead abstract them into small composable pieces. For inspiration see the monad combinators in Control.Monad (e.g. <code>sequence</code>, <code>forever</code>, <code>mapM</code>).</p></li>
</ol>
<p>These principals are not specific to monads. They are applicable to all side-effect heavy programing problems. These principles can also be applied to imperative programs for great justice.</p>
<p>A lot of patterns like reactive programming, dataflow programming and CQRS are consequences of following principals such as these.</p>
<p>The pithy take-away is don't &quot;update, execute, update&quot;. Instead &quot;represent, transform, compose&quot;.</p>
<pre class="open"><code>An open-ended question:

Why is it a good idea to make side effects explicit?</code></pre>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="lets-make-a-guessing-game">Let's Make a Guessing Game</h1>
<h2 id="solution-toolbox">Solution Toolbox</h2>
<p>In order to solve the problem the following toolbox of functions can be used:</p>
<table>
<colgroup>
<col width="12%" />
<col width="3%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Tool</th>
<th align="left">Details</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">bla</td>
<td align="left">bla</td>
</tr>
</tbody>
</table>
<pre class="answer" data-language="haskell" data-filter="resources/scripts/check.sh"><code>
import System.Random

main :: IO ()
main = do
    print &quot;Let&#39;s play the number guessing game&quot;
    n &lt;- randomRIO (1, 10)
    game n

game :: Int -&gt; IO ()
game n = do
    print &quot;Enter a number&quot;
    g &lt;- readLn
    case compare g n of LT -&gt; print &quot;Too low :(&quot;  &gt;&gt; game n
                        GT -&gt; print &quot;Too high :(&quot; &gt;&gt; game n
                        EQ -&gt; print &quot;You win!&quot;

</code></pre>

</div>
</div>


			<hr>
			<p class="center footer"> Produced with
				<a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>
				- Source on
				<a href="https://github.com/composeconference/compose_haskell_workshop">GitHub</a>
			</p>
		</div>
		<script type="text/javascript" src="resources/javascript/rainbow-custom.min.js"></script>
		<script type="text/javascript" src="resources/javascript/answers.js"></script>
		<script type="text/javascript" src="resources/javascript/collapse.js"></script>
		<script type="text/javascript" src="resources/javascript/sum_times.js"></script>
	</body>
</html>
