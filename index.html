<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<title>Melbourne Haskell Workshop 2015</title>
		<link href="resources/css/styles.css"          rel="stylesheet" type="text/css">
		<link href="resources/css/toc.css"             rel="stylesheet" type="text/css">
		<link href="resources/css/fonts.css"           rel="stylesheet" type="text/css">
		<link href="resources/css/solarized-light.css" rel="stylesheet" type="text/css">
	</head>
	<body class="">
		<div id="content">



<div class='chapter'>
<div class='content'>

<h1 id="melbourne-haskell-workshop-2015">Melbourne Haskell Workshop 2015</h1>
<!-- Trickery to conditionally display the alternate format link -->
<h3 id="html-link" class="center"><a href="http://sordina.github.io/haskell_workshop/">(HTML)</a></h3>
<div class="important">
<script type="text/javascript">
	document.getElementById('html-link').remove()
	document.write("<h3 class='center'><a href='workshop.pdf'>(PDF)</a></h3>")
</script>
<pre class="note notitle"><code>Press &quot;o&quot; to toggle only showing the most important content
Press &quot;t&quot; to toggle showing the table of contents</code></pre>
</div>
<div class="center important">
<p>A single-day workshop intended to introduce Haskell to newcomers to functional-programming.</p>
</div>
<!-- https://www.flickr.com/photos/fatmandy/4221136071/in/photolist-7r1qG8-4Ew9ka-7GmuKi-7GH1pP-65YZoM-nGeWhj-7KAY7X-nS3L1Y-j1TkSn-8Ef3BW-6CHTcd-9QVtVW-oDN5ak-4BMnsd-cUC6HY-9QSD52-hseG5J-9vPTiH-CkmeT-bQZgze -->
<div class="center nopad">
<img src="resources/images/workshop.png" alt="Workshop" />
</div>
<p>Outcomes include...</p>
<ul>
<li>Creating, editing, running and interacting with Haskell programs</li>
<li>Building the confidence to solve problems in the wild with Haskell</li>
<li>Developing an understanding of the Haskell ecosystem</li>
<li>Interacting with others in a collaborative environment</li>
</ul>
<div class="important note">
<p>If you are attending the workshop, make sure that you RSVP via <a href="http://www.meetup.com/Melbourne-Haskell-Users-Group/events/219493786/">Meetup</a>. Please also attempt to have the required items from the <a href="#resources">'Resources'</a> section available for your use during the workshop.</p>
<p>If you would like to volunteer, please send an email to the <script type="text/javascript">
<!--
h='&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#46;&#x63;&#x6f;&#x6d;';a='&#64;';n='&#x6d;&#x65;&#108;&#98;&#x2d;&#104;&#x61;&#x73;&#x6b;&#x65;&#108;&#108;&#x2d;&#x77;&#x6f;&#114;&#x6b;&#x73;&#104;&#x6f;&#112;&#x2d;&#x6f;&#114;&#x67;&#x61;&#110;&#x69;&#x73;&#x65;&#114;&#x73;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+'mailing list'+'<\/'+'a'+'>');
// -->
</script><noscript>&#x6d;&#x61;&#x69;&#108;&#x69;&#110;&#x67;&#32;&#108;&#x69;&#x73;&#116;&#32;&#40;&#x6d;&#x65;&#108;&#98;&#x2d;&#104;&#x61;&#x73;&#x6b;&#x65;&#108;&#108;&#x2d;&#x77;&#x6f;&#114;&#x6b;&#x73;&#104;&#x6f;&#112;&#x2d;&#x6f;&#114;&#x67;&#x61;&#110;&#x69;&#x73;&#x65;&#114;&#x73;&#32;&#x61;&#116;&#32;&#x67;&#x6f;&#x6f;&#x67;&#108;&#x65;&#x67;&#114;&#x6f;&#x75;&#112;&#x73;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#x6f;&#x6d;&#x29;</noscript>, or contact us via the meetup.</p>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="table-of-contents">Table of Contents</h1>
<div id="toc" class="important">
<!-- Note: This is a special file that determines the order of the chapters                  -->
<!--       The lefthand column refers to the filename of the chapter in 'resources/markdown' -->
<!--       This column is removed before the markdown is processed for the table of contents -->
<!--       ';' is a comment                                                                  -->
<table>
<tbody>
<tr class="odd">
<td align="left"><a href="#required-resources">Resources</a></td>
<td align="left">Resources Available and Required</td>
<td align="left">1m</td>
</tr>
<tr class="even">
<td align="left"><a href="#welcome">Welcome</a></td>
<td align="left">Motivation, Overview, and Approac</td>
<td align="left">15m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#setup">Setup</a></td>
<td align="left">Setting up your Haskell environme</td>
<td align="left">15m</td>
</tr>
<tr class="even">
<td align="left"><a href="#introduction">Introduction</a></td>
<td align="left">Introductory Exercises</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#types">Types</a></td>
<td align="left">The Haskell Type System</td>
<td align="left">30m</td>
</tr>
<tr class="even">
<td align="left"><a href="#adts-algebraic-data-types">ADTs</a></td>
<td align="left">Modelling with data in Haskell</td>
<td align="left">1h</td>
</tr>
<tr class="odd">
<td align="left"><a href="#lunch-break">~ Lunch Break ~</a></td>
<td align="left">Nandos -&gt; IO Nomnomnomnomnom</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#laziness">Laziness</a></td>
<td align="left">Evaluation when required</td>
<td align="left">1h</td>
</tr>
<tr class="odd">
<td align="left"><a href="#typeclasses">Type-Classes</a></td>
<td align="left">Polymorphism, FP style</td>
<td align="left">30m</td>
</tr>
<tr class="even">
<td align="left"><a href="#music">Wildcard</a></td>
<td align="left">Music</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#monads">Monads</a></td>
<td align="left">IO Monad, Do-Notation</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#ecosystem">Ecosystem</a></td>
<td align="left">Resources and Community</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#moar">~ MOAR!! ~</a></td>
<td align="left">Awesome Extras!</td>
<td align="left">~</td>
</tr>
<tr class="even">
<td align="left"><a href="#testing">Testing</a></td>
<td align="left">Testing with QuickCheck</td>
<td align="left">1h</td>
</tr>
<tr class="odd">
<td align="left"><a href="#symbolic-differentiation">Algebra</a></td>
<td align="left">Symbolic Mathematics</td>
<td align="left">30m</td>
</tr>
<tr class="even">
<td align="left"><a href="#website">Web-Site</a></td>
<td align="left">Making a Web-Site with Scotty</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#compression">Compression</a></td>
<td align="left">Compression</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#post-mortem">Post-Mortem</a></td>
<td align="left">Analysis of the Workshop</td>
<td align="left">~</td>
</tr>
<tr class="odd">
<td align="left"><a href="#appendix">Appendix</a></td>
<td align="left">Appendix</td>
<td align="left">~</td>
</tr>
</tbody>
</table>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>

<h1 id="monads">Monads</h1>
<h2 id="no-seriously-what-are-monads">No seriously, what are Monads?</h2>
<p>A monad is just a bunch of rules. There are many, many analogies for monads out there. Each of these analogies are useful, but can be obscuring on their own, they are just one view point. To effectively wield monads we must use many different view points together, each one revealing a little piece of the underlying structure of monads. Each view point becomes another tool in our mental toolbox.</p>
<p>So there is no one magic-bullet analogy for monads, only many complementary ones.</p>
<p>Haskell uses monads to represent side-effects. The simplist and most practical analogy is the &quot;tainted value&quot; analogy. In haskell the function that reads a file looks like this:</p>
<pre class="nocheck" data-language="haskell"><code>readFile :: FilePath -&gt; IO String</code></pre>
<p>This function can't return a normal string, because the return value has been tainted by side effects. So the IO monad is acting as a tag saying that the returned string must be treated specially.</p>
<p>But an <code>IO String</code> is not very useful to us, because we want to actually do things with it. So Haskell, in its normal paternalistic style, allows us access the <code>String</code> inside an <code>IO String</code> only in a very careful way. We use an operation call bind <code>(&gt;&gt;=)</code> to access the string.</p>
<pre class="nocheck" data-language="haskell"><code>(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b

-- Here specialized for IO and String

(&gt;&gt;=) :: IO String -&gt; (String -&gt; IO b) -&gt; IO b</code></pre>
<p>This says the only way we can &quot;look inside&quot; an <code>IO String</code> is by providing a function that takes a <code>String</code> and returns some other new value that has also been tainted by the outside world. In other words we can only look at a value &quot;inside&quot; the <code>IO</code> monad if we promise to make sure our result will also be tainted.</p>
<p>This means that if some code uses a value from the outside world, even deep inside, it cannot be hidden, it must be made explicit in the type. Tainting is a one way street, once you are tainted you can't be untainted. There is no function <code>untaint :: IO a -&gt; a</code>. One can't get an untainted value from a tainted one.</p>
<p>In fact, in haskell, the very way we construct a useful program is by ultimately creating value of type <code>IO ()</code> that we assign to special variable called <code>main</code>.</p>
<pre class="instruction"><code>Why can&#39;t one write untaint?
If you could what problems would this cause?</code></pre>
<p>One thing that can be a little strange is the type of <code>getLine</code>. In imperative languages, functions of zero arguments make some sense. They can be thought of recipies or to-do lists. In haskell a total function of type <code>() -&gt; Foo</code> is isomorphic to a constant <code>Foo</code>. Because the function only has one input value and therefore only one possible output value.</p>
<p>So let us return to <code>getLine</code>. In an imperative language it would look like <code>getLine :: () -&gt; String</code>. Our first problem is that the return value of this function is tainted by the outside world, so we need to use the <code>IO</code> monad, <code>getLine :: () -&gt; IO String</code>. Now because of the isomorphism between unit domian functions and constants we can just write <code>getLine :: IO String</code>. We call a constant of type <code>IO a</code> an &quot;IO action&quot;. Because it stands for a bunch of side effects that will be performed together.</p>
<p>This will seem strange at first, because getLine isn't really a function -- it's just a constant value! But that's okay because while the <code>IO String</code> is a constant (i.e. there is only one distinct IO action that reads a line from the console) the value <em>inside</em> the monad is not constant. It can be different each time we look inside.</p>
<pre class="nocheck" data-language="haskell"><code>&gt; getLine
hello
&quot;hello&quot;

&gt; getLine
monad
&quot;monad&quot;

&gt; getLine &gt;&gt;= (\name -&gt; putStrLn (&quot;Hello &quot; ++ name))
andy
Hello andy</code></pre>
<h2 id="one-thing-leads-to-another">One thing leads to another</h2>
<p>Often when doing IO one wants to make sure one thing happens after another, We can use <code>(&gt;&gt;=)</code> and just ignore the unwrapped value:</p>
<pre class="nocheck" data-language="haskell"><code>putStr &quot;Hello &quot; &gt;&gt;= (\_ -&gt; putStrLn &quot;World&quot;)

putStrLn &quot;One&quot; &gt;&gt;= (\_ -&gt; putStrLn &quot;Two&quot;) &gt;&gt;= (\_ -&gt; putStrLn &quot;Three&quot;)</code></pre>
<p>This pattern can be easily abstracted, it has been standardized as <code>(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</code>. This can be read as &quot;and then&quot;.</p>
<pre class="nocheck" data-language="haskell"><code>putStr &quot;Hello &quot; &gt;&gt; putStrLn &quot;World&quot;

putStrLn &quot;One&quot; &gt;&gt; putStrLn &quot;Two&quot; &gt;&gt; putStrLn &quot;Three&quot;</code></pre>
<pre class="instruction"><code>Write a program that prints something stupid, funny or rude.
Make sure to use (&gt;&gt;) somewhere.</code></pre>
<h2 id="monad-wars-iii-return-of-the-value">Monad Wars III: Return of the Value</h2>
<p>We mentioned before that there is no way to untaint a value, once it has been tainted, we can make new tainted values from it, but never untainted ones. But that begs the question, can we choose to taint a value? Indeed we can, in fact, this is a fundamental operation of a Monad. In haskell it is confusingly called <code>return :: a -&gt; IO a</code>.</p>
<p>A common pattern is to &quot;open up&quot; an <code>IO</code> with bind <code>(&gt;&gt;=)</code>, mess around with the contents then wrap it back up again with <code>return</code>. We have a function to help us with this called <code>lift</code>. Specialized for <code>IO</code> it has type <code>lift :: (a -&gt; b) -&gt; (IO a -&gt; IO b)</code>. We can use this to take a vanilla function and &quot;lift&quot; it into the IO monad. It works by unwrapping the IO monad calling our function and then wrapping the result back up again.</p>
<pre class="instruction"><code>use return to write &#39;myLiftIO :: (a -&gt; b) -&gt; IO a -&gt; IO b&#39;</code></pre>
<h2 id="do-it-do-it-good.">Do it, do it good.</h2>
<p>Sometimes when you are doing a lot of ad-hoc interleaved IO, using bind and return all over the place can become a pain in the fingers. So haskell provides special syntax for using monads, called &quot;do notation&quot;.</p>
<p>To use do notation, we start a &quot;do block&quot; with the keyword <code>do</code>. Inside a do block, statements can be written line by line and they are automatically joined using &quot;and then&quot; <code>(&gt;&gt;)</code>. This causes them to be run one after the other like in an imperative programming language. One can also easily unwrap monad values and bind them to a variable with using a left arrow &quot;&lt;-&quot; syntax.</p>
<pre class="nocheck" data-language="haskell"><code>  main = do
    putStrLn &quot;Hello World&quot;
    putStrLn &quot;Enter your name: &quot;
    name &lt;- getLine
    putStrLn (&quot;Hello: &quot; ++ name)</code></pre>
<p>The do-notation is like a DSL, under the hood it is just expanded to a chain of bind <code>(&gt;&gt;=)</code> calls. Here is what the above code would look like without do-notation:</p>
<pre class="nocheck" data-language="haskell"><code>  main  =
    putStrLn &quot;Hello World&quot; &gt;&gt;
    putStrLn &quot;Enter your name: &quot; &gt;&gt;
    getLine &gt;&gt;= (\ name -&gt;
      putStrLn (&quot;Hello: &quot; ++ name))</code></pre>
<pre class="instruction"><code>Write a program that asks for someone&#39;s first and second name,
then complements them (or makes fun of them).

For extra points ask for their age, and customize the complement
(insult) depending on how old they are.

Do it with do-notation first, then &quot;desugar&quot; it into raw bind (&gt;&gt;=) calls</code></pre>
<pre class="instruction"><code>My father once told me about an &quot;amazing AI&quot; that his
magician/programmer friend build, which could answer any yes/no
question as well as a human.

Of course it only worked if his friend was the one typing
the question! The trick being that it just counted the
number of spaces in the question. If there was an even number
it would output true, if there was an odd number, false.
You just fiddled with the wording, or snuck in an extra space,
to get the answer that you wanted...

Looks like it&#39;s time to write your super-dooper
human-level AI and see if your friends can figure
out how it works.</code></pre>
<h2 id="stay-functional-san-diego">Stay Functional, San Diego</h2>
<p>Even when we are programming with side effects, we still want our programs to follow functional principals. To stop our code ending up like C written in do-notation, there are some principals we can try to follow:</p>
<ol style="list-style-type: decimal">
<li><p>Try to do most of the work inside pure functions.</p></li>
<li><p>Don't create an IO action until the last possible moment.</p></li>
<li><p>Be declarative, think of program as declaring a pipeline or specifying an interaction, instead of being a to-do list.</p></li>
<li><p>Avoid mixing control, state and calculation. Instead abstract them into small composable pieces. For inspiration see the monad combinators in Control.Monad (e.g. <code>sequence</code>, <code>forever</code>, <code>mapM</code>).</p></li>
</ol>
<p>These principals are not specific to monads. They are applicable to all side-effect heavy programing problems. These principles can also be applied to imperative programs for great justice.</p>
<p>A lot of patterns like reactive programming, dataflow programming and CQRS are consequences of following principals such as these.</p>
<p>The pithy take-away is don't &quot;update, execute, update&quot;. Instead &quot;represent, transform, compose&quot;.</p>
<pre class="open"><code>An open-ended question:

Why is it a good idea to make side effects explicit?</code></pre>

</div>
</div>


			<hr>
			<p class="center footer"> Produced with
				<a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>
				- Source on
				<a href="https://github.com/sordina/haskell_workshop_2015#melbourne-haskell-workshop-2015">GitHub</a>
			</p>
		</div>
		<script type="text/javascript" src="resources/javascript/rainbow-custom.min.js"></script>
		<script type="text/javascript" src="resources/javascript/answers.js"></script>
		<script type="text/javascript" src="resources/javascript/collapse.js"></script>
		<script type="text/javascript" src="resources/javascript/sum_times.js"></script>
	</body>
</html>
