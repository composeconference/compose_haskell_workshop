<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<title>Melbourne Haskell Workshop 2013</title>
		<link href="resources/css/styles.css"          rel="stylesheet" type="text/css">
		<link href="resources/css/toc.css"             rel="stylesheet" type="text/css">
		<link href="resources/css/fonts.css"           rel="stylesheet" type="text/css">
		<link href="resources/css/solarized-light.css" rel="stylesheet" type="text/css">
	</head>
	<body class="">
		<div id="content">

<div class='chapter'>
<div class='content'>



<h1 id="melbourne-haskell-workshop-2013">Melbourne Haskell Workshop 2013</h1>
<ul>
<li>6 Hours (Plus Lunch)</li>
<li>Expected attendance - 50 people</li>
</ul>
<!-- Trickery to conditionally display the alternate format link -->

<h3 id="html-link" class="center"><a href="http://sordina.github.io/haskell_workshop/">(HTML)</a></h3>
<div class="important">

<script type="text/javascript">
	document.getElementById('html-link').remove()
	document.write("<h3 class='center'><a href='workshop.pdf'>(PDF)</a></h3>")
</script>


<pre class="note notitle"><code>Press &quot;o&quot; to toggle only showing the most important content
Press &quot;t&quot; to toggle showing the table of contents</code></pre>
</div>

<hr />
<div class="center important">

<p>A 6-hour workshop intended to introduce and provide resources for working with Haskell.</p>
</div>

<!-- http://upload.wikimedia.org/wikipedia/commons/0/0c/Potter's_workshop_VA.jpg -->
<div class="center nopad"> 
<img src="resources/images/workshop.png" alt="Workshop" />
</div>

<p>This workshop is based around a central concept of domain modeling with Haskell.</p>
<p>Outcomes include...</p>
<ul>
<li>Creating, editing, running and interacting with Haskell programs</li>
<li>Building the confidence to solve problems in the wild with Haskell</li>
<li>Developing an understanding of the Haskell ecosystem</li>
<li>Interacting with others in a collaborative environment</li>
</ul>
<div class="important note">

<p>If you are attending the workshop, make sure that you RSVP via <a href="http://www.meetup.com/Melbourne-Functional-User-Group-MFUG/events/132307572/">Meetup</a>. Please also attempt to have the required items from the <a href="#resources">'Resources'</a> section available for your use during the workshop.</p>
<p>If you would like to volunteer, please subscribe to the <a href="http://www.reddit.com/r/mhw2013/">mhw2013</a> sub-reddit and list yourself on the wiki.</p>
</div>


</div>
</div>




<div class='chapter'>
<div class='content'>

<hr />
<h1 id="table-of-contents">Table of Contents</h1>
<div id="toc" class="important">

<!-- Note: This is a special file that determines the order of the chapters                  -->
<!--       The lefthand column refers to the filename of the chapter in 'resources/markdown' -->
<!--       This column is removed before the markdown is processed for the table of contents -->
<!--       ';' is a comment                                                                  -->

<table>
<tbody>
<tr class="odd">
<td align="left"><a href="#required-resources">Resources</a></td>
<td align="left">Resources Available and Required</td>
<td align="left">1m</td>
</tr>
<tr class="even">
<td align="left"><a href="#welcome">Welcome</a></td>
<td align="left">Motivation, Overview, and Approac</td>
<td align="left">15m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#setup">Setup</a></td>
<td align="left">Setting up your Haskell environme</td>
<td align="left">15m</td>
</tr>
<tr class="even">
<td align="left"><a href="#introduction">Introduction</a></td>
<td align="left">Introductory Exercises</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#types">Types</a></td>
<td align="left">The Haskell Type System</td>
<td align="left">30m</td>
</tr>
<tr class="even">
<td align="left"><a href="#adts-algebraic-data-types">ADTs</a></td>
<td align="left">Modelling with data in Haskell</td>
<td align="left">1h</td>
</tr>
<tr class="odd">
<td align="left"><a href="#lunch-break">~ Lunch Break ~</a></td>
<td align="left">Nandos -&gt; IO Nomnomnomnomnom</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#laziness">Laziness</a></td>
<td align="left">Evaluation when required</td>
<td align="left">1h</td>
</tr>
<tr class="odd">
<td align="left"><a href="#typeclasses">Type-Classes</a></td>
<td align="left">Polymorphism, FP style</td>
<td align="left">30m</td>
</tr>
<tr class="even">
<td align="left"><a href="#music">Wildcard</a></td>
<td align="left">Music</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#monads">Monads</a></td>
<td align="left">IO Monad, Do-Notation</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#ecosystem">Ecosystem</a></td>
<td align="left">Resources and Community</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#moar">~ MOAR!! ~</a></td>
<td align="left">Awesome Extras!</td>
<td align="left">~</td>
</tr>
<tr class="even">
<td align="left"><a href="#testing">Testing</a></td>
<td align="left">Testing with QuickCheck</td>
<td align="left">1h</td>
</tr>
<tr class="odd">
<td align="left"><a href="#symbolic-differentiation">Algebra</a></td>
<td align="left">Symbolic Mathematics</td>
<td align="left">30m</td>
</tr>
<tr class="even">
<td align="left"><a href="#website">Web-Site</a></td>
<td align="left">Making a Web-Site with Scotty</td>
<td align="left">30m</td>
</tr>
<tr class="odd">
<td align="left"><a href="#compression">Compression</a></td>
<td align="left">Compression</td>
<td align="left">1h</td>
</tr>
<tr class="even">
<td align="left"><a href="#appendix">Appendix</a></td>
<td align="left">Appendix</td>
<td align="left">~</td>
</tr>
</tbody>
</table>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="required-resources">Required Resources</h1>
<p>Before you begin you will require the following...</p>
<h2 id="a-text-editor" class="important">A Text-Editor</h2>
<p>We are assuming previous programming experience, however, if you would like a recommendation, have a look at <a href="http://notepad-plus-plus.org/">Notepad++</a>, <a href="http://www.sublimetext.com/">Sublime Text</a>, or the ever-popular <a href="http://www.gnu.org/software/emacs/">Emacs</a> and <a href="http://www.vim.org/">Vim</a>. Just make sure that you are fluent enough to embark on exercises as they appear in the workshop.</p>
<h2 id="the-haskell-platform" class="important"><a href="http://www.haskell.org/platform/">The Haskell Platform</a></h2>
<p>In order to run the programs written during this workshop you will need a Haskell installation. The easiest way to get up and running is to install the latest Haskell Platform. This is a &quot;batteries included&quot; installation of GHC and Cabal that includes many of the most useful packages available in the Hackage ecosystem.</p>
<h2 id="a-copy-of-the-workshop-scaffold-project" class="important"><a href="https://github.com/sordina/haskell_workshop">A Copy of the Workshop Scaffold Project</a></h2>
<p><a href="https://github.com/sordina/haskell_workshop">https://github.com/sordina/haskell_workshop</a></p>
<p>Either clone with git:</p>
<pre class="shell"><code>git clone https://github.com/sordina/haskell_workshop.git</code></pre>
<p>... or <a href="https://github.com/sordina/haskell_workshop/archive/master.zip">download the zip</a> from GitHub.</p>
<h1 id="useful-resources" class="collapse">Useful Resources</h1>
<p>These resources are available to help you with any issues you face when learning Haskell:</p>
<h2 id="haskell-on-freenode">#haskell on <a href="http://freenode.net/">Freenode</a></h2>
<p>An IRC channel dedicated to discussion of Haskell. This is often the easiest place to fire off a one-off question that is simple enough not to warrant a permanent listing on the internet.</p>
<h2 id="hackage"><a href="http://hackage.haskell.org/packages/hackage.html">Hackage</a></h2>
<p>Hackage is the primary repository for Haskell packages. It is public, searchable, versioned, and uses Cabal package metadata for classification. Furthermore, this can be used to easily browse package contents, documentation and source-code.</p>
<p>For example, browse the <a href="http://hackage.haskell.org/package/shake">Shake</a> package and look at some of the <a href="http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake-Command.html">Modules</a>.</p>
<h2 id="hoogle"><a href="http://www.haskell.org/hoogle/">Hoogle</a></h2>
<p>Hoogle is a Haskell module and function search-engine. Hoogle allows you to take advantage of the granular type-system used by Haskell to search not just for function-names, but for function type-signatures.</p>
<p>For example, have a look for the function with signature <a href="http://www.haskell.org/hoogle/?hoogle=Text+-%3E+ByteString">Text -&gt; ByteString</a>.</p>
<h2 id="mfug"><a href="http://www.meetup.com/Melbourne-Functional-User-Group-MFUG/">MFUG</a></h2>
<p>MFUG is the Melbourne Functional Programmer's User Group. This group discusses many topics, including Haskell.</p>
<h2 id="rhaskell"><a href="http://www.reddit.com/r/haskell">/r/haskell</a></h2>
<p>For Reddit users, /r/haskell is a very useful resource with a great deal of information regarding recent developments in the Haskell ecosystem and community. This is a good place to ask some more advanced questions or start a flame-war.</p>
<h2 id="haskell-news"><a href="http://haskellnews.org/">Haskell News</a></h2>
<p>Haskell News is a firehose-style haskell news aggregator taking information from sources as varied as academic-journals, and GitHub accounts.</p>
<h2 id="hlint"><a href="http://hackage.haskell.org/package/hlint">HLint</a></h2>
<p>HLint is a <a href="http://en.wikipedia.org/wiki/Lint_(software)">linting tool</a> for Haskell source - It can often provide some useful hints about refactoring avenues for your code.</p>
<h2 id="learn-you-a-haskell-for-great-good"><a href="http://learnyouahaskell.com/">Learn You a Haskell (For Great Good)</a></h2>
<p>Learn You a Haskell (For Great Good) is a wonderful introductory text on Haskell.</p>
<h2 id="real-world-haskell"><a href="http://book.realworldhaskell.org/">Real World Haskell</a></h2>
<p>Real World Haskell aims to focus on solving real problems with Haskell. Several chapters of the book are somewhat dated in terms of the libraries used, but it still serves as a useful example of getting real work done with Haskell.</p>
</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="welcome">Welcome</h1>
<div class="important">

<p>Welcome to the Melbourne Haskell Workshop 2013.</p>
<p>This intent of this workshop is to provide a working introduction to Haskell for programmers in Melbourne who have not yet used the language in anger.</p>
<p>The workshop is split into chapters. The chapters will start with a few trivial introductory exercises to get your fingers warmed up, then the meat - exercises that should be able to be solved using the material introduced up to that point (with help and hints available if needed).</p>
<p>Each chapter will conclude with an open-question. This question should provide inspiration for further consideration of how harder problems could be solved using Haskell, and for more advanced attendees, can be attacked instead of twiddling your thumbs after finishing the main exercise.</p>
<p>The workshop will be split into pre, and post lunch parts, with additional exercises available for busy beavers following the <a href="#moar">MOAR</a> section of the table of contents.</p>
</div>

<h2 id="why-run-a-free-haskell-workshop">Why run a free haskell workshop?</h2>
<p>There are a few kinds of benefits that we anticipate will result as an outcome of the workshop:</p>
<ul>
<li>Benefits to Individuals</li>
<li>Benefits to the Community</li>
<li>Benefits to the Volunteers</li>
<li>Benefits to the Organisers</li>
<li>Benefits to Industry</li>
<li>Benefits to Relationships</li>
</ul>
<h3 id="benefits-to-individuals">Benefits to Individuals</h3>
<ul>
<li>New Tools</li>
<li>Experience writing Haskell</li>
<li>An Introduction to the Wider Community</li>
</ul>
<p>What do we hope that an individual attendee will gain by coming to the workshop?</p>
<p>Since this workshop is targeted towards beginners, we want an attendee to come away from the workshop with new tools at their disposal. Yes, a new language to reimplement existing knowledge with various platform benefits, but more importantly, a new tool for dissecting problems.</p>
<p>Learning a new problem-solving approach will almost certainly be the most challenging part of the workshop, but through the consistent delivery of exercises that benefit from domain modelling, we hope that the attendee will walk away with the confidence to attack new problems from the &quot;Haskell Mindset&quot;.</p>
<p>Although there won't be time to work on any large-scale problems, we hope that the approaches we demonstrate will be able to be applied with confidence to problems of any size.</p>
<p>Aside from the technical benefits, the workshop should provide a great opportunity for attendees to meet many other members of the Melbourne Haskell using community.</p>
<h3 id="benefits-to-the-community">Benefits to the Community</h3>
<ul>
<li>Haskell as a Tool for Communication</li>
<li>Local Network Effects</li>
<li>Consolidation</li>
</ul>
<p>Often, Haskell (especially the type-system) can be an extremely effective means of communication of certain kinds of behaviors, requirements, and problems. If this workshop can help advance Haskell as a common language for inter-personal discussion of technical topics, then the barriers of communication will be lowered and the community as a whole should become more productive.</p>
<p>Often, it isn't until a particular community reaches a critical mass that it comes into its own. Currently the Melbourne Haskell community is reasonably disparate and unconnected (especially outside of MFUG). If the various groups of people using Haskell can be consolidated, then we would consider starting a regular Melbourne Haskell meetup. Just having the ability to ask questions in person can go a long way to advancing confidence in a particular topic, therefore, as the number of Haskell users increases locally, so to will the overall skill of individuals and the community as a whole.</p>
<h3 id="benefits-to-the-volunteers">Benefits to the Volunteers</h3>
<ul>
<li>Experience</li>
<li>Networking</li>
</ul>
<p>We hope that for the volunteers, providing administrative and in-person assistance will be a rewarding experience. We are very open to people of any skill level helping out and this could be a great opportunity for newcomers to the community to get their fingers dirty by providing assistance at the workshop.</p>
<p>The workshop should also be a good networking opportunity for volunteers, as a stratified group of Haskellers of this size has not yet convened in Melbourne.</p>
<h3 id="benefits-to-industry">Benefits to Industry</h3>
<p>It has been said that once you are comfortable programming Haskell, you become spoiled, and won't want to go back to your previous languages. Rather than quit your day-job, if Haskell's presence can be advanced in industry, then the Joy of programming haskell will become a possibility in your day-to-day work-life. A longer-term goal to be sure.</p>
<p>This benefit may be the most tenuous outcome of the workshop, but as the mindshare of Haskell grows, the chances of it being used for projects within industry increases.</p>
<ul>
<li>As an understanding of the language's strengths and weaknesses emerges, decision makers are empowered to weigh up if the language is a suitable candidate for solving the technical problems at hand.</li>
<li>Confidence is gained that there are enough people using the language that hiring a programmer will not be a problem if this is required.</li>
</ul>
<p>The technical benefits to industry will have the most impact where a rigorous solution to a problem is necessary. In the financial sector, Haskell is beginning to become more popular as the cost of bugs can be very high. Technical benefits, however, are a moot point if Haskell does not see adoption.</p>
<p>If this workshop can give project-leaders in industry, making programming-language choices, the confidence to consider Haskell as a real candidate, then it will have gone a long way towards making Melbourne a more attractive place to be for people who wish to use Haskell in day-to-day work.</p>
<h3 id="benefits-to-the-organisers">Benefits to the Organisers</h3>
<p>Last-but-not-least -</p>
<div class="important">

<p>For us, the organisers, running this workshop will be a great opportunity to see the Melbourne Haskell community in action. We're looking forward to working with you all and expect that, above all else, we will have a lot of...</p>
<h2 id="fun"><em>Fun!</em></h2>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="setup">Setup</h1>
<div class="important">
<p>Ensure that you have the following programs installed and functioning correctly:</p>
<h2 id="ghci">GHCi</h2>
</div>

<p>At a command prompt, enter the following command:</p>
<pre class="shell"><code>ghci</code></pre>
<p>This should launch the GHC Haskell REPL.</p>
<p>Type the following to ensure that you have a functioning REPL:</p>
<pre data-language="haskell"><code>1 + 1</code></pre>
<p>This should yield the result:</p>
<pre class="text"><code>2</code></pre>
<pre class="real"><code>You can use GHCi to perform calculations other than just &quot;1 + 1&quot;.

Here is an example session:

&gt; ghci
GHCi, version 7.6.2: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[Prelude] &gt; 1 + 2 + 3
6
[Prelude] &gt; 100 / 2
50.0
[Prelude] &gt; 6 ^ 7
279936
[Prelude] &gt; ^D
Leaving GHCi.</code></pre>
<pre class="instruction"><code>Using GHCi...

Calculate the price of 42-bakers-dozens of eggs at $3 per-egg.</code></pre>
<pre class="answer"><code>[Prelude] 42 * 13 * 3
1638</code></pre>
<h2 id="loading-files-in-ghci" class="important">Loading files in GHCi</h2>
<p>There are many ways to load and execute Haskell code. For the purposes of this workshop, if you do not already have a workflow you are comfortable with, then we suggest the following steps:</p>
<ul>
<li>Write and edit your programs in files ending in the extension &quot;.hs&quot;</li>
<li>When you are ready to test your program, load it into GHCi</li>
<li>After making modifications to your program, reload the program in GHCi</li>
</ul>
<p>Say you had written the following program <code>test.hs</code> in your home directory:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>main = print &quot;hello world&quot;
</code></pre>
<p>Load the file in GHCi to see it in action:</p>
<pre class="shell"><code>&gt; ghci test.hs
GHCi, version 7.6.2: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, modules loaded: Main.
[*Main] &gt; main
&quot;hello world&quot;</code></pre>
<p>... Unfortunately there is a bug in the program, so in your editor you make the change required to print &quot;hello, world&quot; with the mandated comma:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>main = print &quot;hello, world&quot;
</code></pre>
<p>Now, back in GHCi, you can reload the program without exiting the REPL:</p>
<pre class="shell"><code>[*Main] &gt; :reload
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, modules loaded: Main.
[*Main] &gt; main
&quot;hello, world&quot;</code></pre>
<p>Much better!</p>
<pre class="real"><code>You can inspect a value (of function) in ghci with the `:info` command
in order to find out a little about its type and definition:

ghci&gt; :info main
main :: IO ()   -- Defined at test.hs:1:1

If you just wish to see the type of an expresison, you can use
the `:type` command:

ghci&gt; :type main
main :: IO ()</code></pre>
<pre class="instruction"><code>  

* Define a new numeric function in a source file
* Load it in GHCi
* Test your function in GHCi
* Make a modification
* Reload your chages without exiting GHCi
* Test your changes</code></pre>
<h2 id="ghc" class="important">GHC</h2>
<p>Create the following source file (program.hs):</p>
<pre data-language="haskell"><code>main = print &quot;hello world&quot;</code></pre>
<p>Compile the program as follows:</p>
<pre class="shell"><code>ghc --make program.hs</code></pre>
<p>Run the program with the following command:</p>
<pre class="shell"><code>./program</code></pre>
<p>The output should look as follows:</p>
<pre class="text"><code>&quot;hello world&quot;</code></pre>
<pre class="real"><code>Compiled programs are almost always significantly faster than instructions
run inside GHCi. Even greater speed-ups are possible by using the &quot;-O&quot;
optimisation settings for GHC.</code></pre>
<pre class="instruction"><code>Using GHC...

Compile and run hello-world.</code></pre>
<pre class="answer"><code>&gt; echo &#39;main = print &quot;hello homies&quot;&#39; &gt; main.hs
&gt; ghc --make main.hs
[1 of 1] Compiling Main             ( main.hs, main.o )
Linking main ...
&gt; ./main
&quot;hello friends&quot;</code></pre>
<h2 id="cabal" class="important">Cabal</h2>
<p>You should have access to a Cabal installation if you have installed the Haskell Platform.</p>
<p>Check that you have cabal by running:</p>
<pre class="shell"><code>cabal --version</code></pre>
<p>This should output something similar to:</p>
<pre class="text"><code>cabal-install version &lt;VERSION&gt;
using version &lt;VERSION&gt; of the Cabal library</code></pre>
<pre class="instruction"><code>Install the QuickCheck package using cabal.</code></pre>
<pre class="note"><code>The Haskell-Platform will install binaries in
$HOME/Library/Haskell/bin

Make sure that this is on your path.</code></pre>
<pre class="answer"><code>&gt; cabal update # not required if done recently
Downloading the latest package list from hackage.haskell.org
&gt; cabal install quickcheck
...</code></pre>
<pre class="open"><code>An open-ended question:

Given that GHC is largely written in Haskell, how was GHC first compiled?</code></pre>
<pre class="open"><code>An open-ended question:

What are some of the current issues with the Haskell ecosystem?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="introduction">Introduction</h1>
<div class="important">

<p>The following exercises are intended to be used to warm up your fingers, rather than your brain. These should be run through quickly to get you used to using your development environment.</p>
</div>

<h2 id="primitives">Primitives</h2>
<p>Haskell comes pre-packaged with many primitives available in the <code>Prelude</code> module that is included by default, but you should at least make yourself familiar with the following types, and literal syntax:</p>
<table>
<col width="16%" />
<col width="18%" />
<col width="18%" />
<thead>
<tr class="header">
<th align="left">What?</th>
<th align="left">Type</th>
<th align="left">Literal Syntax</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Machine Ints</td>
<td align="left">Int</td>
<td align="left">42</td>
</tr>
<tr class="even">
<td align="left">Strings</td>
<td align="left">String, [Char]</td>
<td align="left">&quot;Hello World&quot;</td>
</tr>
</tbody>
</table>
<pre class="real"><code>You can type any literal directly into GHCi in order to have it echoed right
back at you. This may be useful for sanity checking that you have the syntax
right!

ghci&gt; 42
42</code></pre>
<h2 id="variables">Variables</h2>
<p>In Haskell you can define a variable with the <code>=</code> sign.</p>
<p>Variables can be defined at the top-level (no-indentation):</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myVariable = 2
</code></pre>
<p>Variable names should start with a lowercase letter and contain no spaces, or special characters, besides underscores, numbers, and <code>'</code>.</p>
<p>Some examples of variable names are:</p>
<ul>
<li><code>a</code></li>
<li><code>my_name</code></li>
<li><code>data43'</code></li>
</ul>
<pre class="instruction"><code>Define your own variable.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>x = &quot;hello&quot;
</code></pre>
<pre class="instruction"><code>What is an example of an invalid variable name?</code></pre>
<pre class="answer nocheck" data-language="haskell"><code>invalid-variable = 123</code></pre>
<p>String literals look familiar:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myString = &quot;hello world&quot;
</code></pre>
<pre class="instruction"><code>Define a variable containing a string.</code></pre>
<h2 id="tuples">Tuples</h2>
<p>Tuples look like this:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myTuplePair = (1,&quot;hello&quot;)

myTupleTrio = (1,&quot;hello&quot;,3)
</code></pre>
<p>They can be used to group multiple, differently-typed (heterogeneous) values.</p>
<pre class="instruction"><code>Define a variable containing a tuple.</code></pre>
<h2 id="functions">Functions</h2>
<p>Functions are a core part of Haskell. Function definitions look like this:</p>
<pre class="nocheck" data-language="haskell"><code>myFunction x y ... = ...</code></pre>
<p>For example:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myAdd x y = x + y
</code></pre>
<p><code>myAdd</code> takes two numbers and returns the result of the addition of those two numbers.</p>
<pre class="instruction"><code>Define a function `myMultiply` that multiplies 3 numbers.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply x y z = x * y * z
</code></pre>
<h2 id="lists">Lists</h2>
<p>List are a commonly used data-structure in Haskell. Everything in a list has the same type (they are homogeneous).</p>
<p>Lists are built using the infix data-constructor <code>(:)</code> (pronounced &quot;cons&quot;). They also have a compact notation using <code>[...]</code>.</p>
<p>List literals look like:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>list1 = [1,2,3]
list2 = 1 : 2 : []
list3 = &quot;hello&quot; : &quot;world&quot; : []
</code></pre>
<p>More information about why lists can be used the way that they are is contained in the <a href="#adts-algebraic-data-types">ADTs</a> chapter.</p>
<pre class="instruction"><code>Define a variable containing a list.</code></pre>
<p>You can deconstruct a list by pattern matching the head and tail like so:</p>
<pre class="nocheck" data-language="haskell"><code>f (x:xs) = ...</code></pre>
<pre class="instruction"><code>Define a function to get the first element of a list.</code></pre>
<p>Note: In <code>Prelude</code> this function is called <code>head</code>.</p>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myHead (x:xs) = x -- This is a partial function, Beware!
</code></pre>
<pre class="instruction"><code>Define a variable containing the first element of your list.</code></pre>
<pre class="answer nocheck" data-language="haskell"><code>myFirstElement = myHead myList</code></pre>
<h3 id="define-length">Define Length</h3>
<pre class="instruction"><code>Define a function that takes a list and returns the length.</code></pre>
<p>Your solution should have the form of:</p>
<pre class="nocheck" data-language="haskell"><code>myLength []     = ...
myLength (x:xs) = ...</code></pre>
<p>Things to consider:</p>
<ul>
<li>What is the length of an empty list? (the base case)</li>
<li>What is the length of xs?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myLength []     = 0
myLength (x:xs) = 1 + myLength xs
</code></pre>
<h3 id="define-mymap">Define <code>myMap</code></h3>
<pre class="instruction"><code>
  
Define a function that takes a function from a to b,
and a list of &#39;a&#39;, and returns a list of &#39;b&#39;s.</code></pre>
<p>Some concrete examples of such a function may do the following:</p>
<ul>
<li>Take a function that divides integers by two, list of ints, and returns a list of doubles.</li>
<li>Take a function that turns lowercase into uppercase characters, and a String, and returns a string in CAPS.</li>
</ul>
<p>Things to consider:</p>
<ul>
<li>What is the base-case of myMap?</li>
<li>What is the inductive-case of myMap?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMap f [] = []
myMap f (x:xs) = f x : myMap f xs
</code></pre>
<h2 id="fun-list-functions">Fun List Functions</h2>
<p>For your reading pleasure, here are some definintions of common functions:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFilter f []     = []
myFilter f (x:xs) = if f x then x : myFilter f xs
                           else     myFilter f xs

myFold f z []     = z
myFold f z (x:xs) = f x (myFold f z xs)

myReverse []     = []
myReverse (x:xs) = myReverse xs ++ [x]

myElem e []     = False
myElem e (x:xs) = if e == x then True
                            else myElem e xs
</code></pre>
<pre class="open"><code>An open-ended question:

What is a good balance between safety and expressiveness in a
programming-language?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="types">Types</h1>
<pre class="note.notitle"><code>Question: How do you create a great program?
Answer:   You type it!</code></pre>
<p>In this chapter, we will go over the exercises from the introduction and add types to the examples.</p>
<hr />
<p>In Haskell, type signatures can be provided inline, or above definitions.</p>
<p>For example:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>x :: Int
x = 3
</code></pre>
<p>or</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>x = (3 :: Int)
</code></pre>
<p>It is far more common to place the type-signature above the definition, with inline types only used in situations where ambiguities need to be resolved.</p>
<div class="important">

<pre class="instruction nobefore"><code>You are defining a floating point variable:</code></pre>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFloat = 1.1
</code></pre>
<pre class="instruction"><code>Give your variable a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFloat :: Float
myFloat = 1.1
</code></pre>
</div>

<h2 id="type-synonyms">Type Synonyms</h2>
<p>In Haskell, we can give type-expressions an alias (or synonym) by using the <code>type</code> keyword. This allows you to cut down the verbosity and chance of errors in your code when you have type expressions that would otherwise be repeated frequently.</p>
<p>An example of this is the <code>String</code> type-synonym, which is defined as follows:</p>
<pre class="nocheck" data-language="haskell"><code>type String = [Char]</code></pre>
<pre class="instruction"><code> 

Give your string variable from the previous chapter a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myString :: String
myString = &quot;Hello Haskell&quot;
</code></pre>
<h2 id="tuples-1">Tuples</h2>
<p>Tuple type signatures look the same as the tuples themselves, with types in place of the data.</p>
<p>For example, if you had a tuple of a String and an Int, the type would look as follows:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myTuple :: (String, Int)
myTuple = (&quot;The meaning of life&quot;, 42)
</code></pre>
<pre class="instruction"><code>Give your previous tuple definition a type signature.</code></pre>
<h2 id="functions-1">Functions</h2>
<p>The type signatures of functions in Haskell are a little different from how they look in the more familiar C family languages, but the syntax is very elegant, and will allow a higher-level of reasoning than less consistant forms.</p>
<p>The syntax for a function type-signarure is of the form:</p>
<pre class="nocheck" data-language="haskell"><code>{functionName} :: {argument} -&gt; {result}</code></pre>
<p>The main idea is that functions in Haskell only ever take one argument. If you wish to define a function that takes more than one argument, then you should, infact, define a function that takes one argument, then returns another function.</p>
<p>Luckily the syntax for doing this in Haskell looks identical to defining a multi-argument function:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply x y z = x * y * z
</code></pre>
<p>However, the distinction becomes clear with the type-signature:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply :: Int -&gt; (Int -&gt; (Int -&gt; Int))
myMultiply x y z = x * y * z
</code></pre>
<p>It is clear, that the function only takes one argument, then returns a function (that only takes one argument, and returns a function (that only takes one argument, that returns an Int.))</p>
<p>Fortunately, Haskell's function syntax is right-associative, allowing us to drop the parentheses:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply :: Int -&gt; Int -&gt; Int -&gt; Int
myMultiply x y z = x * y * z
</code></pre>
<pre class="instruction"><code> 

Define a function `myMultiply` that multiplies 4 numbers.
Give your function a type-signature</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMultiply :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int
myMultiply w x y z = w * x * y * z
</code></pre>
<h2 id="lists-1">Lists</h2>
<p>List type-signatures look like:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>list1 :: [Int]
list2 :: [Int]
list3 :: [String]

list1 = [1,2,3]
list2 = 1 : 2 : []
list3 = &quot;hello&quot; : &quot;world&quot; : []

list1A :: ([]) Int
list1A = [1]
</code></pre>
<p>List type signatures are special in that the type-constructor is &quot;Around&quot;-fix. This is not generally possible, and lists are a special case in that regard.</p>
<p>If you find you need to, you can use the list type in prefix-form, as per variable <code>list1A</code>.</p>
<pre class="instruction"><code>Define a list variable and give it a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myList :: [Int]
myList = [1,2,3]
</code></pre>
<pre class="instruction"><code>Give your `head` deconstructor function a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myHead :: [a] -&gt; a
myHead (x:xs) = x
</code></pre>
<h3 id="length-signature">Length Signature</h3>
<pre class="instruction"><code>Give your length function a type-signature.</code></pre>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myLength :: [a] -&gt; Int
myLength []     = 0
myLength (x:xs) = 1 + mylength xs
</code></pre>
<h3 id="map-signature">Map Signature</h3>
<pre class="instruction"><code>Give your `map` function a type-signature.</code></pre>
<p>Things to consider:</p>
<ul>
<li>What is the type of the first argument of myMap?</li>
<li>What is the second argument, etc?</li>
<li>What is the type of the result of myMap?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myMap :: (a -&gt; b) -&gt; [a] -&gt; [b]
myMap f [] = []
myMap f (x:xs) = f x : myMap f xs
</code></pre>
<h2 id="fun-list-functions-types">Fun List Functions Types</h2>
<p>Here are the types for the definintions of the list functions from the previous chapter:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>myFilter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
myFilter f []     = []
myFilter f (x:xs) = if f x then x : myFilter f xs
                           else     myFilter f xs

myFold :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
myFold f z []     = z
myFold f z (x:xs) = f x (myFold f z xs)

myReverse :: [a] -&gt; [a]
myReverse []     = []
myReverse (x:xs) = myReverse xs ++ [x]

myElem :: Eq a =&gt; a -&gt; [a] -&gt; Bool
myElem e []     = False
myElem e (x:xs) = if e == x then True
                            else myElem e xs
</code></pre>
<p>See if you can determine the type-signatures for these functions.</p>
<pre class="open"><code>An open-ended question:

How many types could a type-checker check...
... if a type checker could check types?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="adts-algebraic-data-types">ADTs (Algebraic Data Types)</h1>
<div class="center">
<a href="http://www.haskell.org/haskellwiki/Algebraic_data_type">Haskell Wiki Link</a>
</div>

<p>Algebraic Data Types are THE bread and butter of Haskell programs.</p>
<ul>
<li>Functions evaluate data by pattern-matching against ADTs</li>
<li>Domains are modeled using ADTs</li>
<li>Laziness is linked to ADTs</li>
<li>Types can be derived from ADT definitions</li>
</ul>
<div class="collapse">

<p>But how does that help me?</p>
<p>An example of an ADT in Haskell:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyBool = MyTrue | MyFalse | MyNotSure

should_I_eat_something_bigger_than_my_own_head :: MyBool
should_I_eat_something_bigger_than_my_own_head = MyFalse
</code></pre>
<pre class="real"><code>With this functionality, you are able to introduce your own &quot;Enum&quot;
values.

The MyBool example is somewhat equivalent to the following C++ code:

enum MyBool { MyTrue, MyFalse, MyNotSure };

With the added bonus of not having out-of-bounds casting ruin your day.

If your problem space can be moddeled using various discrete values,
then this form of ADT will allow you to create a program that mirrors
your problem!</code></pre>
<p>You can add parameters to the data constructors:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyNullString = Nada | MyString String

stringy :: MyNullString
stringy = MyString &quot;Whatever, It&#39;s just a string&quot;

blanky :: MyNullString
blanky = Nada
</code></pre>
<p>Constructors can take multiple parameters:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data SomeJunk = Rubbish String | TrashPile String Int Bool

discards :: SomeJunk
discards = TrashPile &quot;Junk Yard&quot; 42 True
</code></pre>
<p>Furthermore, ADTs can be recursive:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyNumberList = Nada | SomeNumbers Int MyNumberList

numbers :: MyNumberList
numbers =  SomeNumbers 1 (SomeNumbers 2 Nada)
</code></pre>
<p>Finally, ADTs can be parametrised by other types:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyContainer x = Jar x

contained :: MyContainer Int
contained = Jar 1

pun :: MyContainer (MyContainer String)
pun = Jar (Jar &quot;Binks&quot;)
</code></pre>
<p>In general, the syntax of an ADT looks similar to the following:</p>
<pre class="bnf"><code>ADT          := data &lt;TypeName&gt; &lt;Variables&gt; = &lt;Constructors&gt;
TypeName     := [A-Z] + [a-z&#39;_]*
Parameters   := &lt;ConcreteType&gt; + (&quot; &quot; + &lt;ConcreteType&gt;)*
Constructors := &lt;Constructor&gt; + (&quot; | &quot; + &lt;Constructor&gt;)*
Constructor  := &lt;TypeName&gt; + &lt;Parameters&gt;
Variables    := &lt;Variable&gt; + (&quot; &quot; + &lt;Variable&gt;)*
Variable     := [a-z] + [a-z&#39;_]*</code></pre>
<p>ConcreteType can't be defined syntactically, but it means that your type is &quot;Fully Applied&quot; (in Haskell terms, has a kind of <code>*</code>). An example of some concrete types are:</p>
<ul>
<li><code>String</code></li>
<li><code>Int</code></li>
<li><code>Maybe String</code></li>
<li><code>[Int]</code></li>
</ul>
<p>Examples of some non-concrete types are:</p>
<ul>
<li><code>Maybe</code></li>
<li><code>IO</code></li>
<li><code>(-&gt;)</code></li>
</ul>
<h2 id="deriving">Deriving</h2>
<p>One final thing to note is that in order to be able to print values of your data types at the GHCi REPL, you will need your data to be a member of the <code>Show</code> type-class.</p>
<p><em>Type-classes are covered in depth in the <a href="#typeclasses">type-classes</a> chapter.</em></p>
<p>This is achieved by appending the following text after your data definition:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyData = SuperGreat deriving (Show)
</code></pre>
<p>Similar classes are needed for ordering and equality. If you get stuck on a missing class, just add the following deriving triple for now:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyData = SuperGreat deriving (Eq, Ord, Show)
</code></pre>
<h2 id="exercises">Exercises</h2>
<p>With all of this power at your disposal, it's time to define a list ADT yourself.</p>
</div>

<pre class="instruction"><code>Define your own generic list ADT.</code></pre>
<p>Things to consider:</p>
<ul>
<li>Should this ADT be parametrised?</li>
<li>Should this ADT be recursive?</li>
<li>Should this ADT have multiple constructors?</li>
<li>Should the constructors be parametrised?</li>
</ul>
<pre class="answer" data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data MyList a = Empty | Items a (MyList a)
</code></pre>
<pre class="open"><code>An open-ended question:

What would the ADT for a Lisp-like language look like?</code></pre>
<div class="note">
<p>If you wish to learn about why ADTs are &quot;Algebraic&quot;, then have a look at:</p>
<ul>
<li><a href="http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/">The Algebra of Algebraic Data Types, Part 1</a></li>
<li><a href="http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/">The Algebra of Algebraic Data Types, Part 2</a></li>
<li><a href="http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/">The Algebra of Algebraic Data Types, Part 3</a>
</div>
</li>
</ul>
</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="lunch-break">Lunch Break</h1>
<div class="center important">

<p>Lunch is provided courtesy of <a href="http://www.thoughtworks.com/">ThoughtWorks</a></p>
<div class="center"> 
<img src="resources/images/chicken.png" alt="Chicken Dinner" />
</div>

</div>

</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="laziness">Laziness</h1>
<div class="center">

<p><em>Haskell's evaluation strategies ~ Exploring the magic.</em></p>
</div>

<p>Often when looking at examples of Haskell functions you will come across examples of laziness in action. The canonical example used to demonstrate the lazy recursive approach of Haskell is the definition of the list of Fibonacci numbers -</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
</code></pre>
<p>This solution has a reputation for being somewhat mind-bending for beginners... What is going on here?</p>
<pre class="real"><code>In order to show the start of an infinite list, use the `take` function -

For example:

[Prelude] &gt; let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
[Prelude] &gt; take 10 fibs
[1,1,2,3,5,8,13,21,34,55]</code></pre>
<p>Here is a Fibonacci solution in Javascript:</p>
<pre data-language="javascript"><code>function fib(n) {
	if(n &lt; 2) return 1
	return fib(n-1) + fib(n-2)
}</code></pre>
<p>Most programmers won't have any problem with the usual recursive definition of <code>fibs</code>, so what makes the Haskell one special? Let's see if we can implement the Haskell version in Javascript:</p>
<pre data-language="javascript"><code>// The Fibonacci Sequence in all its glory~
//
function fibs() { return [1, cons(1, zipWith(add, fibs, tail( fibs )))] }

exports.main = function() { runList(fibs, 13) }

// Helpers
//
function cons(h,t)        { return function() { return [h,t] }}
function head(list)       { return list()[0] }
function add(x,y)         { return x + y }
function tail(list)       { return function() { return list()[1]() }}

function zipWith(f, x, y) { return function() {
                            return [ f(head(x), head(y)),
                                     zipWith(f, tail(x), tail(y))] } }

function runList(list, n) { while(n --&gt; 0) {
                            console.log(head(list)); list = tail(list)}}</code></pre>
<p>The main difference between a normal recursive definition and this one is that the recursion happens at the value level, as opposed to the function-call location.</p>
<pre class="instruction"><code> 

Implement an infinite list of ascending numbers using lazy,
value-based recursion.</code></pre>
<pre class="answer" data-language="haskell" data-filter="resources/scripts/check.sh"><code>ascending = 1 : zipWith (+) ascending ascending
</code></pre>
<pre class="open"><code>An open-ended question:

Can all numeric-lists be defined by using value-based recursion?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>

<h1 id="typeclasses">Type Classes</h1>
<p>A big part of writing clean reusable code is controlled polymorphism. We are like a carny at the roller-coaster, anybody can ride the roller coaster, but you must be at least this tall.</p>
<p>In the object oriented world we use the inheritance heirachy, we know that if something is a subclass, it has at least all of the features of its parent. Of course this is all intertwined with the sharing of data and state, and that's bad.</p>
<p>In the functional world we get type classes, which is just controlled polymorphism without the baggage. They basically say, that I don't need to know exactly what type you'll call me with but you need to provide a bunch of functions for me to use.</p>
<p>A function tells you what type classes it needs with a &quot;context&quot;, The context is the bit to the left of the double arrow &quot;=&gt;&quot;</p>
<pre class="nocheck" data-language="haskell"><code>(+) :: Num a =&gt; a -&gt; a -&gt; a

show :: Show a =&gt; a -&gt; String</code></pre>
<p>In the above example, we have <code>(+)</code>. It can work for any type that is a number. There are built in types for numbers and you can also define your own.</p>
<p><code>show</code> can turn any &quot;Showable&quot; type into a string. this is analogous to the <code>toString()</code> method in Java.</p>
<pre class="instruction"><code>Define a function that adds one to everything in a list.
What is the type of this function?</code></pre>
<pre class="nocheck" data-language="haskell"><code>read :: Read a =&gt; String -&gt; a

incrementAndshow :: (Num a, Show a) =&gt; a -&gt; String</code></pre>
<p>Unlike most other languages, with some kind of type driven function dispatch (e.g. methods, overloading). Haskell can also use the <em>return</em> type of the function to choose functionality, this can take a little getting used to, but it is powerful.</p>
<p><code>read</code> turns a string into a value of another type, although we don't know what this is yet. It depends, for example on the type of the function that you are passing the result of read into.</p>
<p><code>incrementAndShow</code> demonstrates a function that uses two type classes in its context.</p>
<pre class="instruction"><code>In ghci, convert a string to an integer using read, then covert
a string into a list of integers using read.

(Hint: use (::) to add a type to an expression)

If you just type &#39;read &quot;1&quot;&#39; in ghci you get an
error, why is this?</code></pre>
<pre class="instruction"><code>Define `incrementAndShow` which adds one to a number and
coverts it to a string.
What is they type of this function?
How did haskell infer your context?</code></pre>
<h1 id="defining-your-own-type-classes">Defining Your Own Type Classes</h1>
<p>Let's define a type class of things that can be rated, as in 1 to 5 stars or awesome to lame.</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>
data Rating = 
  SoAwesomeICried |
  PrettyCool      |
  Meh             |
  ForTheLoveOfGodMakeItEnd
  deriving Show

class Rateable r where
  rating :: r -&gt; Rating


data Beer = Coopers | Fosters | CarltonDraught
  deriving Show

instance Rateable Beer where
  rating Coopers = PrettyCool
  rating Fosters = ForTheLoveOfGodMakeItEnd
  rating CarltonDraught = Meh


data Movie = Movie String
  deriving Show

instance Rateable Movie where
  rating (Movie &quot;Bladerunner&quot;) = SoAwesomeICried
  rating (Movie &quot;Tron&quot;) = PrettyCool
  rating _ = Meh

</code></pre>
<p>When we define a type class we write out the name and the types of the functions that we want associated with this type class. We also put a type variable in our definition which refers to whatever type may instance this type class later. We can use this type variable in the definitions below. At this point we can also define default definitions for the functions.</p>
<p>We then define two new data types, <code>Beer</code> and <code>Movie</code> for which we add an &quot;instance declaration&quot; this is where we write the definitions of the type class functions specialized for beers of movies.</p>
<p>We now know how to manually add type class definitions and we could add custom <code>Show</code> instances for each of our new datatypes. However this would be a bunch of boilerplate nonsense, so we can use the handy deriving directive to automatically add a <code>Show</code> instance for us.</p>
<pre class="instruction"><code>Create your own Rateable type class and wacky Rating datatype.
Then create datatypes and instances for something you have a
strong opinion about, like cars or a political party.</code></pre>
<pre class="instruction"><code>Add a review function to your type class that returns
a short textual review.</code></pre>
<pre class="instruction"><code>Add a Rateable instance for a native type, like String.</code></pre>
<p>There are a few other cool things you can do with typeclasses that are not covered here. So if you want to know more, check out some of these other articles:</p>
<p><a href="http://www.haskell.org/tutorial/classes.html">http://www.haskell.org/tutorial/classes.html</a></p>
</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="music">Music</h1>
<p>When you are modeling a problem of a sufficient level of complexity you will find that your data-types often become recursive. One domain that sits roughly on this threshold is music.</p>
<!-- http://i824.photobucket.com/albums/zz163/Boysie8/Telecaster%20build/f-hole.jpg -->
<div class="center"> 
<img src="resources/images/f-hole.jpg" alt="Music F-Hole" />
</div>

<p>Here is a small musical target-language:</p>
<pre data-language="haskell"><code>data Music
  = A_ -- Underscore Represents a Flat
  | A
  | A&#39; -- Prime represents a Sharp
       -- ... B, C, D, E, F, G ...
  | Sequence [Music]
  | Sharp Music
  | Longer Integer Music
  | Higher Integer Music</code></pre>
<p>Certainly not comprehensive enough to write Beethoven's 5th Symphony, but good enough for Baa Baa Black-Sheep.</p>
<pre data-language="haskell"><code>intro  = Sequence [ C, C, G, G ]
run    = Sequence [ A, B, C, A ]
middle = Sequence [ F, F, E, E ]
run2   = Sequence [ D, C, D, E ]
baaBaa = Sequence [ Longer 2  intro
                  , Higher 12 run
                  , Longer 4  G
                  , Longer 2  middle
                  , run2
                  , Longer 4  C ]</code></pre>
<p>In order to listen to this music, create a file with the following code:</p>
<pre data-language="haskell"><code>import Midi
import qualified Data.ByteString as BS

main = BS.writeFile &quot;baaBaa.mid&quot; (make_music 4 4 (Longer 4 baaBaa))</code></pre>
<pre class="instruction"><code> 
  
Write a melody using this language. Try to write and compose
functions, rather than declaring one big data-structure.

Why not try writing Beethoven&#39;s 5th Symphony after all?</code></pre>
<pre class="open"><code>An open question:
  
What kinds of music is this language incapable of modeling?
How would you modify this language to be more inclusive?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>

<h1 id="monads">Monads</h1>
<h2 id="no-seriously-what-are-monads">No seriously, what are Monads?</h2>
<p>A monad is just a bunch of rules. There are many, many analogies for monads out there. Each of these analogies are useful, but can be obscuring on their own, they are just one view point. To effectively wield monads we must use many different view points together, each one revealing a little piece of the underlying structure of monads. Each view point becomes another tool in our mental toolbox.</p>
<p>So there is no one magic-bullet analogy for monads, only many complementary ones.</p>
<p>Haskell uses monads to represent side-effects. The simplist and most practical analogy is the &quot;tainted value&quot; analogy. In haskell the function that reads a file looks like this:</p>
<pre class="nocheck" data-language="haskell"><code>readFile :: FilePath -&gt; IO String</code></pre>
<p>This function can't return a normal string, because the return value has been tainted by side effects. So the IO monad is acting as a tag saying that the returned string must be treated specially.</p>
<p>But an <code>IO String</code> is not very useful to us, because we want to actually do things with it. So Haskell, in its normal paternalistic style, allows us access the <code>String</code> inside an <code>IO String</code> only in a very careful way. We use an operation call bind <code>(&gt;&gt;=)</code> to access the string.</p>
<pre class="nocheck" data-language="haskell"><code>(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b

-- Here specialized for IO and String

(&gt;&gt;=) :: IO String -&gt; (String -&gt; IO b) -&gt; IO b</code></pre>
<p>This says the only way we can &quot;look inside&quot; an <code>IO String</code> is by providing a function that takes a <code>String</code> and returns some other new value that has also been tainted by the outside world. In other words we can only look at a value &quot;inside&quot; the <code>IO</code> monad if we promise to make sure our result will also be tainted.</p>
<p>This means that if some code uses a value from the outside world, even deep inside, it cannot be hidden, it must be made explicit in the type. Tainting is a one way street, once you are tainted you can't be untainted. There is no function <code>untaint :: IO a -&gt; a</code>. One can't get an untainted value from a tainted one.</p>
<p>In fact, in haskell, the very way we construct a useful program is by ultimately creating value of type <code>IO ()</code> that we assign to special variable called <code>main</code>.</p>
<pre class="instruction"><code>Why can&#39;t one write untaint?
If you could what problems would this cause?</code></pre>
<p>One thing that can be a little strange is the type of <code>getLine</code>. In imperative languages, functions of zero arguments make some sense. They can be thought of recipies or to-do lists. In haskell a total function of type <code>() -&gt; Foo</code> is isomorphic to a constant <code>Foo</code>. Because the function only has one input value and therefore only one possible output value.</p>
<p>So let us return to <code>getLine</code>. In an imperative language it would look like <code>getLine :: () -&gt; String</code>. Our first problem is that the return value of this function is tainted by the outside world, so we need to use the <code>IO</code> monad, <code>getLine :: () -&gt; IO String</code>. Now because of the isomorphism between unit domian functions and constants we can just write <code>getLine :: IO String</code>. We call a constant of type <code>IO a</code> an &quot;IO action&quot;. Because it stands for a bunch of side effects that will be performed together.</p>
<p>This will seem strange at first, because getLine isn't really a function -- it's just a constant value! But that's okay because while the <code>IO String</code> is a constant (i.e. there is only one distinct IO action that reads a line from the console) the value <em>inside</em> the monad is not constant. It can be different each time we look inside.</p>
<pre class="nocheck" data-language="haskell"><code>&gt; getLine
hello
&quot;hello&quot;

&gt; getLine
monad
&quot;monad&quot;

&gt; getLine &gt;&gt;= (\name -&gt; putStrLn (&quot;Hello &quot; ++ name))
andy
Hello andy</code></pre>
<h2 id="one-thing-leads-to-another">One thing leads to another</h2>
<p>Often when doing IO one wants to make sure one thing happens after another, We can use <code>(&gt;&gt;=)</code> and just ignore the unwrapped value:</p>
<pre class="nocheck" data-language="haskell"><code>putStr &quot;Hello &quot; &gt;&gt;= (\_ -&gt; putStrLn &quot;World&quot;)

putStrLn &quot;One&quot; &gt;&gt;= (\_ -&gt; putStrLn &quot;Two&quot;) &gt;&gt;= (\_ -&gt; putStrLn &quot;Three&quot;)</code></pre>
<p>This pattern can be easily abstracted, it has been standardized as <code>(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</code>. This can be read as &quot;and then&quot;.</p>
<pre class="nocheck" data-language="haskell"><code>putStr &quot;Hello &quot; &gt;&gt; putStrLn &quot;World&quot;

putStrLn &quot;One&quot; &gt;&gt; putStrLn &quot;Two&quot; &gt;&gt; putStrLn &quot;Three&quot;</code></pre>
<pre class="instruction"><code>Write a program that prints something stupid, funny or rude.
Make sure to use (&gt;&gt;) somewhere.</code></pre>
<h2 id="monad-wars-iii-return-of-the-value">Monad Wars III: Return of the Value</h2>
<p>We mentioned before that there is no way to untaint a value, once it has been tainted, we can make new tainted values from it, but never untainted ones. But that begs the question, can we choose to taint a value? Indeed we can, in fact, this is a fundamental operation of a Monad. In haskell it is confusingly called <code>return :: a -&gt; IO a</code>.</p>
<p>A common pattern is to &quot;open up&quot; an <code>IO</code> with bind <code>(&gt;&gt;=)</code>, mess around with the contents then wrap it back up again with <code>return</code>. We have a function to help us with this called <code>lift</code>. Specialized for <code>IO</code> it has type <code>lift :: (a -&gt; b) -&gt; (IO a -&gt; IO b)</code>. We can use this to take a vanilla function and &quot;lift&quot; it into the IO monad. It works by unwrapping the IO monad calling our function and then wrapping the result back up again.</p>
<pre class="instruction"><code>use return to write &#39;myLiftIO :: (a -&gt; b) -&gt; IO a -&gt; IO b&#39;</code></pre>
<h2 id="do-it-do-it-good.">Do it, do it good.</h2>
<p>Sometimes when you are doing a lot of ad-hoc interleaved IO, using bind and return all over the place can become a pain in the fingers. So haskell provides special syntax for using monads, called &quot;do notation&quot;.</p>
<p>To use do notation, we start a &quot;do block&quot; with the keyword <code>do</code>. Inside a do block, statements can be written line by line and they are automatically joined using &quot;and then&quot; <code>(&gt;&gt;)</code>. This causes them to be run one after the other like in an imperative programming language. One can also easily unwrap monad values and bind them to a variable with using a left arrow &quot;&lt;-&quot; syntax.</p>
<pre class="nocheck" data-language="haskell"><code>  main = do
    putStrLn &quot;Hello World&quot;
    putStrLn &quot;Enter your name: &quot;
    name &lt;- getLine
    putStrLn (&quot;Hello: &quot; ++ name)</code></pre>
<p>The do-notation is like a DSL, under the hood it is just expanded to a chain of bind <code>(&gt;&gt;=)</code> calls. Here is what the above code would look like without do-notation:</p>
<pre class="nocheck" data-language="haskell"><code>  main  =
    putStrLn &quot;Hello World&quot; &gt;&gt;
    putStrLn &quot;Enter your name: &quot; &gt;&gt;
    getLine &gt;&gt;= (\ name -&gt;
      putStrLn (&quot;Hello: &quot; ++ name))</code></pre>
<pre class="instruction"><code>Write a program that asks for someone&#39;s first and second name,
then complements them (or makes fun of them).

For extra points ask for their age, and customize the complement
(insult) depending on how old they are.

Do it with do-notation first, then &quot;desugar&quot; it into raw bind (&gt;&gt;=) calls</code></pre>
<pre class="instruction"><code>My father once told me about an &quot;amazing AI&quot; that his
magician/programmer friend build, which could answer any yes/no
question as well as a human.

Of course it only worked if his friend was the one typing
the question! The trick being that it just counted the
number of spaces in the question. If there was an even number
it would output true, if there was an odd number, false.
You just fiddled with the wording, or snuck in an extra space,
to get the answer that you wanted...

Looks like it&#39;s time to write your super-dooper
human-level AI and see if your friends can figure
out how it works.</code></pre>
<h2 id="stay-functional-san-diego">Stay Functional, San Diego</h2>
<p>Even when we are programming with side effects, we still want our programs to follow functional principals. To stop our code ending up like C written in do-notation, there are some principals we can try to follow:</p>
<ol style="list-style-type: decimal">
<li><p>Try to do most of the work inside pure functions.</p></li>
<li><p>Don't create an IO action until the last possible moment.</p></li>
<li><p>Be declarative, think of program as declaring a pipeline or specifying an interaction, instead of being a to-do list.</p></li>
<li><p>Avoid mixing control, state and calculation. Instead abstract them into small composable pieces. For inspiration see the monad combinators in Control.Monad (e.g. <code>sequence</code>, <code>forever</code>, <code>mapM</code>).</p></li>
</ol>
<p>These principals are not specific to monads. They are applicable to all side-effect heavy programing problems. These principles can also be applied to imperative programs for great justice.</p>
<p>A lot of patterns like reactive programming, dataflow programming and CQRS are consequences of following principals such as these.</p>
<p>The pithy take-away is don't &quot;update, execute, update&quot;. Instead &quot;represent, transform, compose&quot;.</p>
<pre class="open"><code>An open-ended question:

Why is it a good idea to make side effects explicit?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="ecosystem">Ecosystem</h1>
<p>The Haskell ecosystem is large and interesting, it is held together more by convention than by dictation, with the current convention being that open source packages are made available through <code>cabal</code> on Hackage.</p>
<h2 id="cabal-1">Cabal</h2>
<p>Cabal is a library package, but &quot;cabal&quot; is often used to refer to the cabal executable provided by the &quot;cabal-install&quot; package. These packages are both provided by the Haskell Platform.</p>
<p>The premiere online Cabal package repository is <a href="http://hackage.haskell.org/">Hackage.</a></p>
<p>Cabal provides mechanisms for download and installing packages from Hackage onto your system. It also provides a consistent way to structure, export, test, and package your own programs.</p>
<pre class="instruction"><code> 

Install the hlint package from hackage.

Use the `hlint` command-line program to to check for stylistic issues in one
of your previous solutions.</code></pre>
<pre class="answer"><code>Information about the hlint package can be found at

* hackage.haskell.org/package/hlint
* http://www.haskell.org/hoogle/?hoogle=hlint

etc.

The command used to install the hlint package is

&gt; cabal install hlint

Although you may have to run

&gt; cabal update

to ensure that your list of packages is up to date.

Once you have the hlint tool installed you can run it like so:

&gt; hlint dragon.hs

    dragon.hs:35:17: Warning: Redundant $
    Found:
      flip zip (map toLower text) $ dragon_points
    Why not:
      flip zip (map toLower text) dragon_points</code></pre>
<pre class="open"><code>An open-ended question:

How would you go about publishing your own package to Hackage?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>

<h1 id="moar">MOAR PLZ!</h1>
<div class="important">

<p>Hungry for more? Here are some extra sections that cover more advanced haskell awesomeness.</p>
</div>

<div class="center"> 
<img src="resources/images/down_arrow.png" alt="Down Here..." />
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="testing">Testing</h1>
<p>Haskell's type-system allows you to eliminate many kinds of errors that are usually combated using testing in more dynamic languages.</p>
<p>However, just because the type system can prevent some classes of error, doesn't mean that it can catch them all.</p>
<div class="center"> 
<img src="resources/images/pokemotto.png" alt="Pokemon" />
</div>

<p>There are a couple of really useful approaches to testing used commonly by Haskell programmers:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a></li>
<li><a href="http://hackage.haskell.org/package/HUnit">HUnit</a></li>
</ul>
<p>QuickCheck focuses primarily on testing pure code, while HUnit provides means to test code that lives in the IO monad.</p>
<p>In the world of unit-testing, generating data can be a pain. Coming up with concise examples that test edge-cases and don't bother repeating useless properties is a real art-form that can take longer than writing the code to solve the problem at hand.</p>
<p>In many languages, frameworks and libraries have sprung up to aid with this problem by providing ways to generate various forms of valid and invalid test-data on demand.</p>
<p>An example of this form of library in Ruby is <a href="https://github.com/thoughtbot/factory_girl">Factory Girl</a>. You specify the structure and properties of the data you want generated, and using the helpers provided by the framework you will be able to generate many unit tests to ensure that your application's code behaves as expected!</p>
<p>But hang-on... Why would we go about telling a Haskell library what the structure of our data looks like when in a great-deal of cases - Haskell already knows?</p>
<p>This is where the <code>Arbitrary</code> type-class from QuickCheck steps up to bat for us!</p>
<hr />
<p>Let's say that we have a function <code>hyphenate</code> that takes a sentence and turns the spaces into hyphens - There should be no trailing or leading hyphens unless they were already there to begin with, and there should be no instance of multiple hyphens in a row in our output - For example:</p>
<pre><code>&quot;hello world&quot;      =&gt; &quot;hello-world&quot;
&quot;say     whaaaaa?&quot; =&gt; &quot;say-whaaaat?&quot;</code></pre>
<p>We get pretty excited and code up an enterprise solution ~</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>hyphenate :: String -&gt; String
hyphenate s = map (replace &#39; &#39; &#39;-&#39;) s

replace :: Char -&gt; Char -&gt; Char -&gt; Char
replace x y c | c == x    = y
              | otherwise = c
</code></pre>
<p>Great!</p>
<p>Those examples we looked at earlier kind of look like some test-data. Let's write some unit-tests.</p>
<pre class="nocheck" data-language="haskell"><code>test1 :: Bool
test1 = hyphenate &quot;hello world&quot; == &quot;hello-world&quot;

test2 :: Bool
test2 = hyphenate &quot;say     whaaaaa?&quot; == &quot;say-whaaaat?&quot;</code></pre>
<p><em>Awwwwwww yis.</em></p>
<p>... Except test2 fails spectacularly... Hmm...</p>
<p>So we fix our test-data, we fix our function (hopefully?) and code up a few more tests, only to find we missed another edge-case when our client comes back with some trailing hyphens and mad as a raging bull... There has to be a better way!</p>
<p>Enter QuickCheck -</p>
<p>Rather than writing tests for individual applications, we write properties that cover the various specifications of the desired behavior:</p>
<pre class="nocheck" data-language="haskell"><code>import Data.List

prop_no_spaces :: String -&gt; Bool
prop_no_spaces s = not (elem &#39; &#39; (hyphenate s))

prop_no_leading :: String -&gt; Bool
prop_no_leading s = case hyphenate s of (x:xs) -&gt; x /= &#39;-&#39;
                                        _      -&gt; True

prop_no_trailing :: String -&gt; Bool
prop_no_trailing s = prop_no_leading (reverse s)

prop_no_multiple :: String -&gt; Bool
prop_no_multiple s = not (elem &quot;--&quot; (concatMap tails (inits s)))</code></pre>
<pre class="real"><code>The QuickCheck program looks for function names starting with &quot;prop_&quot;.
The program generates random data to test with and expects a True result.</code></pre>
<p>That's all well and good, but how does that help us?</p>
<p>Check this out!</p>
<pre><code>&gt; quickCheck +names hyphen-solution-and-tests.hs
[Prelude] &gt; [1 of 1] Compiling Main ( hy.hs, interpreted )
Ok, modules loaded: Main.
[*Main] &gt; prop_no_spaces: +++ OK, passed 100 tests.
[*Main] &gt; prop_no_leading: *** Failed! (after 44 tests and 7 shrinks):
&quot; &quot;
[*Main] &gt; prop_no_trailing: +++ OK, passed 100 tests.
[*Main] &gt; prop_no_multiple: +++ OK, passed 100 tests.
[*Main] &gt; Leaving GHCi.</code></pre>
<p>ZOMG - So much free test data!</p>
<p>This found an edge-case for us without too much trouble, and what's more, narrowed it down to the minimal failing example!</p>
<pre class="real"><code>If you want to be able to take advantage of QuickCheck in the
fashion performed in the example you will need to install
QuickCheck and quickcheck-script:

&gt; cabal install quickcheck quickcheck-script</code></pre>
<p>In order to take advantage of QuickCheck's data-generation for custom data-types - take a look at the <a href="http://hackage.haskell.org/packages/archive/QuickCheck/2.6/doc/html/Test-QuickCheck-Arbitrary.html">Arbitrary</a> type-class.</p>
<div class="important">

<p>Given that the Fibbonacci sequence is defined as follows:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
</code></pre>
<pre class="instruction"><code> 

Write a property checking that successive Fibbonacci term
pairs sum to the next term.</code></pre>
</div>

</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="symbolic-differentiation">Symbolic Differentiation</h1>
<p>Your Highschool math teacher has decided to introduce differentiation of single-variable polynomials...</p>
<p>This is in super easy once you grasped the concept:</p>
<div class="important">

<p>Polynomial term differentiation:</p>
<div class="center"> 
<br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%20a%20.%20x%5En%20.%20%5Cfrac%7Bd%7D%7Bdx%7D%20%3D%20n.a.x%5E%7Bn-1%7D%20" alt=" a . x^n . \frac{d}{dx} = n.a.x^{n-1} " title=" a . x^n . \frac{d}{dx} = n.a.x^{n-1} " /><br />
</div>

<p>Linearity of differentiation:</p>
<div class="center"> 
<br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28a%20%2B%20b%29%20%5Cfrac%7Bd%7D%7Bdx%7D%20%3D%20a%20%5Cfrac%7Bd%7D%7Bdx%7D%20%2B%20b%20%5Cfrac%7Bd%7D%7Bdx%7D%20" alt=" (a + b) \frac{d}{dx} = a \frac{d}{dx} + b \frac{d}{dx} " title=" (a + b) \frac{d}{dx} = a \frac{d}{dx} + b \frac{d}{dx} " /><br />
</div>

</div>

<p>But you don't wish to perform the undoubtedly large number of rote-examples required after your moment of epiphany.</p>
<pre class="nocheck" data-language="haskell"><code>differentiate :: Polynomial -&gt; Polynomial
differentiate = ...</code></pre>
<div class="important">

<p>The data-types used to represent a <code>Polynomial</code> are as follows:</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>data Constant   = C Int             deriving (Show, Eq)
data Power      = U Int             deriving (Show, Eq)
data Term       = T Constant Power  deriving (Show, Eq)
data Polynomial = P [ Term ]        deriving (Show, Eq)
</code></pre>
<p>The <code>x</code> variable is implicit in the Term data-type.</p>
</div>


<pre class="instruction"><code>
  
Create a function &quot;differentiate&quot; that takes a Polynomial, and returns a new
Polynomial that has been differentiated with respect to x.</code></pre>
<pre class="open"><code>An open ended question:

What would an ADT look like that could model partially-differentiable
multi-varable equations?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>


<h1 id="website">Making a Web-Site with Scotty</h1>
<p>The Haskell library <a href="http://hackage.haskell.org/package/scotty">Scotty</a> is similar to the ruby web-library <a href="http://www.sinatrarb.com/">Sinatra</a>.</p>
<div class="center">

<div class="figure">
<img src="resources/images/scotty.png" alt="Beam me Up" /><p class="caption">Beam me Up</p>
</div>
</div>

<p>Scotty can be installed by using the following Cabal command:</p>
<pre class="shell"><code>&gt; cabal install scotty</code></pre>
<p>Scotty's behaviour is based around <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> verbs and routes.</p>
<p>For example - A simple Hello-World website:</p>
<pre class="nocheck" data-language="haskell"><code>{-# LANGUAGE OverloadedStrings #-}

import Web.Scotty
import Data.Monoid (mconcat)

main = scotty 3000 $ do
  get &quot;/:word&quot; $ do
    beam &lt;- param &quot;word&quot;
    html $ mconcat [&quot;&lt;h1&gt;Scotty, &quot;, beam, &quot; me up!&lt;/h1&gt;&quot;]</code></pre>
<p>If we inspect the type of <code>get</code> in GHCi we see this:</p>
<pre class="ghci"><code>&gt; import Web.Scotty
&gt; :info get
get :: Action action =&gt; RoutePattern -&gt; action -&gt; ScottyM ()
  	-- Defined in `scotty-0.4.6:Web.Scotty.Route&#39;</code></pre>
<p>The ActionM Action type-class instance allows us to perform any IO action we desire, such as printing to the console, reading files, etc - through the use of the liftIO function.</p>
<pre data-language="haskell" data-filter="./resources/scripts/check.sh"><code>{-# LANGUAGE OverloadedStrings #-}

import Web.Scotty
import Control.Monad.IO.Class
import Data.Monoid


myRoute = get &quot;/hello&quot; $ do
  liftIO $ putStrLn &quot;What is your name?&quot;
  myName &lt;- liftIO readLn
  html $ mconcat [&quot;Your name is &quot;, myName, &quot;... Thanks!&quot;]
</code></pre>
<pre class="instruction"><code>Make a simple website using Scotty that shows the current time.</code></pre>
<pre class="hint"><code>Check out the website project in the scaffold folder for an
example of how to put together a Scotty based web-project.</code></pre>
<pre class="open"><code>An open question:

What features do the more advanced Haskell web-frameworks include
that Scotty lacks?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="compression">Compression</h1>
<p>In the scaffold folder <code>compression</code> there is a Cabal project that implements a compression strategy based on <a href="http://en.wikipedia.org/wiki/Huffman_coding">Huffman Coding</a>.</p>
<div class="center">

<div class="figure">
<img src="resources/images/huffmantree.png" alt="Huffman Tree" /><p class="caption">Huffman Tree</p>
</div>
</div>

<p>A Huffman Tree is built recursively by recursively constructing a tree from the two lowest-scored trees in a list, then adding the new tree to the list, until there is only one tree left.</p>
<pre class="nocheck" data-language="haskell"><code>data FingerTree k v = L k (Maybe v) | B k (FingerTree k v) (FingerTree k v)

type HuffmanTree = FingerTree (Sum Int) Char

instance Monoid k =&gt; Monoid (FingerTree k v)
  where x `mappend` y = B (getKey x `mappend` getKey y) x y
        mempty        = L mempty Nothing

getKey :: FingerTree t t1 -&gt; t
getKey (L k _  ) = k
getKey (B k _ _) = k

step :: [HuffmanTree] -&gt; [HuffmanTree]
step []    = []
step [x]   = [x]
step [x,y] = [ x &lt;&gt; y ]
step xs    = step (take 2 sorted) ++ drop 2 sorted
  where
    sorted = sortBy (comparing getKey) xs

build :: [HuffmanTree] -&gt; HuffmanTree
build = head . fromJust . find ((&lt;= 1) . length) . iterate step</code></pre>
<p>The basic idea is that in a non-random string, some combinations of tokens will be more frequent than others, and as-such, common substrings can be represented with a short-hand encoding to save space.</p>
<p>The project contains two executables: <code>compression</code> and <code>decompression</code>. These accept data on STDIN and output data on STDOUT. <code>compression</code> accepts text on STDIN and outputs binary data. Decompression does the reverse.</p>
<pre class="real"><code>The Haskell package &quot;binary&quot; exposes the module &quot;Data.Binary&quot; that
allows for very easy binary serialisation and parsing, with
most existing types already containing a marshelling implementation.</code></pre>
<p>If you install these executables by using <code>cabal install</code>, then you will be able to use them in the following manner:</p>
<pre class="shell"><code>&gt; # Compress
&gt; compression &lt; lyrics.txt &gt; lyrics.txt.compressed
&gt; # Decompress
&gt; decompression &lt; lyrics.txt.compressed</code></pre>
<p>Top down, the compression algorithm works as follows:</p>
<pre class="text"><code>* Determine the frequencies of the characters in the input text from STDIN
* Build a Huffman Tree from the frequency table
* Traverse the tree, outputting Bit-String encodings for each character
* Map a lookup of the encoding table over the input text
* Pack the resulting bits into a ByteString
* Attach a header (containing length, and frequency table)
* Output the result to STDOUT</code></pre>
<p>With the decompression algorithm performing the following:</p>
<pre><code>* Read a ByteString
* Unpack into header (length and frequency table) and body
* Translate frequency-table into encoding table as per compression
* For each encoding match against the start of the compressed body
* Output the character if there is a match
* Process the left-over body</code></pre>
<pre class="note"><code>Unfortunately, the compression algorithm contains a bug.</code></pre>
<pre class="instruction"><code>In the compression scaffolding project, locate and fix the bug
that causes the test-suite to fail.

You can run the tests by calling &quot;cabal test&quot; from within
the project folder.</code></pre>
<pre class="answer nocheck" data-language="haskell"><code>-- Line 131 should be:

treeToBits t = map (second reverse) result</code></pre>
<p>Although the algorithm itself is very basic, and the use of strings instead of binary-data is not a common way to perform compression, the structure itself is typical of a real-world Haskell project. The project structures itself around the Cabal toolkit, and uses several libraries. It exposes a library, several executables, and a test-suite.</p>
<pre class="open"><code>An open question:

How would you implement a more efficient compression algorithm in Haskell?</code></pre>
</div>
</div>




<div class='chapter'>
<div class='content'>


<hr />
<h1 id="appendix">Appendix</h1>
<ul>
<li><a href="http://stackoverflow.com/questions/17870864/where-is-huttons-razor-first-defined">Hutton's Razor</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/">Implementing Functional Languages: A Tutorial</a></li>
<li><a href="http://en.wikipedia.org/wiki/QuickCheck">QuickCheck Wikipedia Page</a></li>
<li><a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck on Hackage</a></li>
<li><a href="http://www.haskell.org/haskellwiki/99_questions">99 Haskell Problems</a></li>
<li><a href="http://hackage.haskell.org/packages/hackage.html">Hackage</a></li>
<li><a href="http://en.wikipedia.org/wiki/Bzip2">BZip</a></li>
<li><a href="http://hackage.haskell.org/package/scotty">Scotty</a></li>
<li><a href="http://www.sinatrarb.com/">Sinatra</a></li>
<li><a href="http://en.wikipedia.org/wiki/Representational_state_transfer">REST</a></li>
<li><a href="https://github.com/colah/HaskSymb">HaskSymb - Symbolic Algebra</a></li>
<li><a href="http://www.haskell.org/tutorial/classes.html">Type-Classes</a></li>
<li><a href="https://www.fpcomplete.com/school">School of Haskell</a></li>
</ul>
<h2 id="contributors">Contributors</h2>
<table>
<tbody>
<tr class="odd">
<td align="left">Lyndon Maydwell</td>
<td align="left"><a href="https://github.com/sordina">GitHub</a></td>
</tr>
<tr class="even">
<td align="left">Andy Kitchen</td>
<td align="left"><a href="https://github.com/andykitchen">GitHub</a>, <a href="https://twitter.com/auastro">Twitter</a></td>
</tr>
<tr class="odd">
<td align="left">Alan Hawkins</td>
<td align="left"><a href="https://github.com/xpika">GitHub</a></td>
</tr>
</tbody>
</table>
<h2 id="volunteers---todo">Volunteers - TODO</h2>
</div>
</div>




			<hr>
			<p class="center footer"> Produced with
				<a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>
				- Source on
				<a href="http://github.com/sordina/haskell_workshop">GitHub</a>
			</p>
		</div>
		<script type="text/javascript" src="resources/javascript/rainbow-custom.min.js"></script>
		<script type="text/javascript" src="resources/javascript/answers.js"></script>
		<script type="text/javascript" src="resources/javascript/collapse.js"></script>
		<script type="text/javascript" src="resources/javascript/sum_times.js"></script>
	</body>
</html>
